<!DOCTYPE html>
<html lang="en">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.8.0'>
  <meta name="generator" content="Hexo 7.3.0">
  <meta name="Volantis" content="5.8.0">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="http://example.com/2024/10/17/leetcode刷题/"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
      <meta name="referrer" content="no-referrer">
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  
  <!-- Custom Files headBegin end-->
  <!-- front-matter head_begin begin -->
  <!-- front-matter head_begin end -->
  <link rel="preload" href="/css/style.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
  <!-- 页面元数据 -->
  <title>leetcode刷题(1) - 圣者纯洁</title>
  <meta name="keywords" content="刷题,null">
  <meta desc name="description" content="这是张俊杰的网站 - 张俊杰 - 圣者纯洁">
  
<meta property="og:type" content="article">
<meta property="og:title" content="leetcode刷题(1)">
<meta property="og:url" content="http://example.com/2024/10/17/leetcode%E5%88%B7%E9%A2%98/index.html">
<meta property="og:site_name" content="圣者纯洁">
<meta property="og:description" content="[@TOC] 数组1、53. 最大子数组和中等 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 123输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。  示例 2： 12输入：nums &#x3D; [1]输出：1">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2024-10-17T13:05:31.000Z">
<meta property="article:modified_time" content="2024-10-17T13:21:08.283Z">
<meta property="article:author" content="张俊杰">
<meta property="article:tag" content="刷题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #fff;
  --color-site-footer: #666;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #30ad91;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #3dd9b6;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #54b5a0 linear-gradient(45deg, rgba(255,255,255,0.4) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.4) 50%, rgba(255,255,255,0.4) 75%, transparent 75%, transparent);
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #2092ec;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-bg {
  position: absolute;
  width: 100%;
  height: 100%;
  background-position: center;
  background-size: cover;
  -webkit-background-size: cover;
  -moz-background-size: cover;
}
.cover-wrapper .cover-bg.lazyload:not(.loaded) {
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
}
.cover-wrapper .cover-bg.lazyload.loaded {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
    transform: scale(1.02);
    -webkit-transform: scale(1.02);
    -khtml-transform: scale(1.02);
    -moz-transform: scale(1.02);
    -o-transform: scale(1.02);
    -ms-transform: scale(1.02);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #3dd9b6;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #3dd9b6;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #3dd9b6;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1080px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1112px;
    left: calc((100% - 1112px) * 0.5);
  }
}
@media screen and (max-width: 1112px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.css"></noscript>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>Sorry, your browser cannot access this site</b></span><br/>`+
        `<span class="kill-c">Microsoft has terminated support for Internet Explorer (IE) 10 and earlier versions in 2016. <br/>There are great security risks to continue using it. Please use contemporary mainstream browsers to access.</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>Learn more ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>Sorry, your browser cannot access this site</b></span><br/>
        <span class="kill-c">This page requires browser support (enable) JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>Learn more ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = "env"; // 调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: "env",
    cdn: {"js":{"app":"/js/app.js","parallax":"/js/plugins/parallax.js","rightMenu":"/js/plugins/rightMenu.js","rightMenus":"/js/plugins/rightMenus.js","sites":"/js/plugins/tags/sites.js","friends":"/js/plugins/tags/friends.js","contributors":"/js/plugins/tags/contributors.js","search":"/js/search/hexo.js"},"css":{"style":"/css/style.css"}},
    default: {"avatar":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg","link":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/link/8f277b4ee0ecd.svg","cover":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg","image":"https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/image/2659360.svg"},
    lastupdate: new Date(1731514380044),
    sidebar: {
      for_page: ["blogger","category","tagcloud","donate"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2020/01/01",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-solid fa-info-circle light-blue","quection":"fa-solid fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"far fa-copyright light-blue"},"aplayer":{"enable":true,"play":"fa-solid fa-play","pause":"fa-solid fa-pause"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  volantis.scroll.ele = null;
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) => {
    if (!ele) return;
    volantis.scroll.ele = ele;
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(() => {
        if (volantis.scroll.ele != ele) {
          return
        }
        volantis.scroll.unengine.push(() => {
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/avatar/round/3442075.svg";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "https://unpkg.com/volantis-static@0.0.1654736714924/media/placeholder/cover/76b86c0226ffd.svg";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
  <!-- front-matter head_end begin -->
  <!-- front-matter head_end end -->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <!-- front-matter body_begin begin -->
    <!-- front-matter body_begin end -->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow floatable blur show" style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
            <img no-lazy class='logo' src='https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/Logo-NavBar@3x.png'/>
          
          
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/more/" title="更多"
                  
                  
                  
                    active-action="action-more"
                  >
                  <i class='fa-solid fa-angles-right&#34; fa-fw'></i>更多
                </a>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="博客"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-solid fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-solid fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-solid fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-solid fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-solid fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-solid fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/more/" title="更多"
                  
                  
                  
                    active-action="action-more"
                  >
                  <i class='fa-solid fa-angles-right&#34; fa-fw'></i>更多
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="none" class='cover-wrapper post search' style="display: none;">
        
  <div class='cover-bg lazyload placeholder' data-bg="https://gitee.com/zhang-junjie123/picture/raw/master/image/u=3499373588,1975088268&fm=253&fmt=auto&app=120&f=JPEG"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">圣者纯洁</p>
    
    
      <p class="subtitle">张俊杰的博客</p>
    
  </div>
  <div class='bottom'>
    
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <input type="text" class="input u-search-input" placeholder="A Wonderful Theme for Hexo" />
          <i class="icon fa-solid fa-search fa-fw"></i>
        </form>
      </div>
    
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/v4/getting-started/"
              
              
              active-action="action-v4getting-started">
              <p>文档</p>
            </a>
          
            <a href="/faqs/"
              
              
              active-action="action-faqs">
              <p>帮助</p>
            </a>
          
            <a href="/examples/"
              
              
              active-action="action-examples">
              <p>示例</p>
            </a>
          
            <a href="/contributors/"
              
              
              active-action="action-contributors">
              <p>社区</p>
            </a>
          
            <a href="/archives/"
              
              
              active-action="action-archives">
              <p>博客</p>
            </a>
          
            <a target="_blank" rel="noopener" href="https://github.com/volantis-x/hexo-theme-volantis/"
              
              
              active-action="action-https:githubcomvolantis-xhexo-theme-volantis">
              <p>源码</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable blur article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="http://example.com/2024/10/17/leetcode刷题/">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="圣者纯洁">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="圣者纯洁">
    <meta itemprop="description" content="这是张俊杰的网站">
  </span>
  


  
    <span hidden>
      <meta itemprop="image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
    </span>
  
  <div class="article-meta" id="top">
    
    
    
      <h1 class="title" itemprop="name headline">
        leetcode刷题(1)
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author' itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a itemprop="url" class='author' href="/" rel="nofollow">
    <img itemprop="image" src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/apple-touch-icon.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
    <p itemprop="name">请设置文章作者</p>
  </a>
</div>

          
        
          
            
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/categories/leetcode/">leetcode</a>
    
      <span hidden itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/leetcode/" itemprop="url"><span itemprop="name">leetcode</span></a>
      </span>
    
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2024-10-17T21:05:31+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Oct 17, 2024</p>
  </a>
</div>

          
        
          
            



          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <p>[@TOC]</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1、53-最大子数组和"><a href="#1、53-最大子数组和" class="headerlink" title="1、53. 最大子数组和"></a>1、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><p>中等</p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong></p>
<p>是数组中的一个连续部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
<p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p>
<p>-2 1 -2 4 3 5 6 1 5 </p>
<p>6 &#x3D; 1 + 5 &#x3D; 1 + (2 + 3) &#x3D; 1 + (2 + (-1 + 4 ))</p>
<h4 id="贪心算法思想："><a href="#贪心算法思想：" class="headerlink" title="贪心算法思想："></a>贪心算法思想：</h4><ul>
<li>若当前指针所指元素之前的和小于0，则丢弃当前元素之前的数列。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self,nums:<span class="type">List</span>[<span class="built_in">int</span>]</span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums: <span class="keyword">return</span> -<span class="number">2147483648</span></span><br><span class="line">    	cur_sum = max_sum = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            cur_sum = <span class="built_in">max</span>(nums[i],cur_sum+nums[i])</span><br><span class="line">            max_sum = <span class="built_in">max</span>(cur_sum,max_sum)</span><br><span class="line">        <span class="keyword">return</span> max_sum</span><br></pre></td></tr></table></figure>



<h4 id="动态规划思想："><a href="#动态规划思想：" class="headerlink" title="动态规划思想："></a>动态规划思想：</h4><ul>
<li><p>若前一个元素大于0，则将其加到当前元素上。</p>
<p>py</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self,nums:<span class="type">List</span>[<span class="built_in">int</span>]</span>)-&gt;<span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i-<span class="number">1</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                nums[i]+=nums[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(nums)</span><br></pre></td></tr></table></figure>

<p>​	java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span> [] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>,maxAns = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x: nums)&#123;</span><br><span class="line">            pre = Math.max(pre ,pre + x);</span><br><span class="line">            maxAns = Math.max(maxAns,pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、704-二分查找-3-23"><a href="#2、704-二分查找-3-23" class="headerlink" title="2、704. 二分查找 (3.23)"></a>2、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a> (3.23)</h3><p>简单</p>
<p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li>你可以假设 <code>nums</code> 中的所有元素是不重复的。</li>
<li><code>n</code> 将在 <code>[1, 10000]</code>之间。</li>
<li><code>nums</code> 的每个元素都将在 <code>[-9999, 9999]</code>之间。</li>
</ol>
<h4 id="我的代码："><a href="#我的代码：" class="headerlink" title="我的代码："></a>我的代码：</h4><h5 id="Python-左闭右闭写法"><a href="#Python-左闭右闭写法" class="headerlink" title="Python   左闭右闭写法"></a>Python   <strong>左闭右闭写法</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right):</span><br><span class="line">        middle = (left + right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">            left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span>  nums[middle] &gt; target:</span><br><span class="line">            right = middle - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左闭右开</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    left = <span class="number">0</span></span><br><span class="line">    right = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">        middle = (left + right)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[middle] &lt; target:</span><br><span class="line">            left = middle + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span>  nums[middle] &gt; target:</span><br><span class="line">            right = middle </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> middle</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="java版本"><a href="#java版本" class="headerlink" title="java版本"></a>java版本</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 左闭右闭</span><br><span class="line">public int search(int[] nums, int target) &#123;</span><br><span class="line">     int left = 0;</span><br><span class="line">     int right = nums.length - 1;</span><br><span class="line">     while(left &lt;= right)&#123;</span><br><span class="line">         int middle = (left + right) / 2;</span><br><span class="line">         if(nums[middle] &lt; target)&#123;</span><br><span class="line">             left = middle + 1;</span><br><span class="line">         &#125;else if(nums[middle] &gt; target)&#123;</span><br><span class="line">             right = middle - 1;</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">             return middle;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return -1;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-、27-移除元素-3-23"><a href="#3-、27-移除元素-3-23" class="headerlink" title="3 、27. 移除元素 (3.23)"></a>3 、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a> (3.23)</h3><p>简单</p>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,3,0,4]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 100</code></li>
</ul>
<h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>双指针法（快慢指针法）： 通过⼀个快指针和慢指针在⼀个for循环下完成两个for循环的工作。<br><strong>定义快慢指针</strong></p>
<p>快&#x2F;右指针 $\textit{fast&#x2F;right}$ 指向当前将要处理的元素，慢&#x2F;左指针 $\textit{slow&#x2F;left}$指向下一个将要赋值的位置。</p>
<ul>
<li><p>如果右指针指向的元素不等于$\textit{val}$，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移；</p>
</li>
<li><p>如果右指针指向的元素等于$\textit{val}$，它不能在输出数组里，此时左指针不动，右指针右移一位。</p>
</li>
</ul>
<h4 id="双指针优化版本"><a href="#双指针优化版本" class="headerlink" title="双指针优化版本"></a>双指针优化版本</h4><p>方法二：双指针优化<br>思路</p>
<p>如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5][1,2,3,4,5][1,2,3,4,5]，当 val\textit{val}val 为 111 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 555 移动到序列开头，取代元素 111，得到序列 [5,2,3,4][5,2,3,4][5,2,3,4]，同样满足题目要求。这个优化在序列中 val\textit{val}val 元素的数量较少时非常有效。</p>
<p>实现方面，我们依然使用双指针，两个指针初始时分别位于数组的首尾，向中间移动遍历该序列。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><p>如果左指针 $\textit{left}$指向的元素等于 $\textit{val}$，此时将右指针 $\textit{right}$ 指向的元素复制到左指针 $\textit{left}$的位置，然后右指针$\textit{right}$ 左移一位。如果赋值过来的元素恰好也等于 $\textit{val}$，可以继续把右指针 $\textit{right}$ 指向的元素的值赋值过来（左指针 $\textit{left}$ 指向的等于 $\textit{val}$ 的元素的位置继续被覆盖），直到左指针指向的元素的值不等于$\textit{val}$ 为止。</p>
<p>当左指针 $\textit{left}$ 和右指针$\textit{right}$ 重合的时候，左右指针遍历完数组中所有的元素。</p>
<p>这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。</p>
<h4 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h4><h5 id="python代码-双指针普通版本"><a href="#python代码-双指针普通版本" class="headerlink" title="python代码  双指针普通版本"></a>python代码  双指针普通版本</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removeElement</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    fast,slow = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (fast&lt;<span class="built_in">len</span>(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[fast] != val:</span><br><span class="line">            nums[slow] = nums[fast]</span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">        fast += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h5 id="java代码-双指针优化版本"><a href="#java代码-双指针优化版本" class="headerlink" title="java代码   双指针优化版本"></a>java代码   双指针优化版本</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">    int fast=0,slow=nums.length;</span><br><span class="line">    while(fast&lt;slow)&#123;</span><br><span class="line">        if(nums[fast] == val)&#123;</span><br><span class="line">            nums[fast]=nums[slow-1];</span><br><span class="line">            slow -= 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            fast += 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return fast;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240323232109652.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240323232109652.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240323232109652"></p>
<h3 id="4、977-有序数组的平方-3-24"><a href="#4、977-有序数组的平方-3-24" class="headerlink" title="4、977. 有序数组的平方(3.24)"></a>4、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a>(3.24)</h3><p>简单</p>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br><span class="line">解释：平方后，数组变为 [16,1,0,9,100]</span><br><span class="line">排序后，数组变为 [0,1,9,16,100]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按 <strong>非递减顺序</strong> 排序</li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>因为有负数，所以平方后的结果，应该是中间最小，两边最大，所以用双指针两边开始遍历，算哪个平方最大，倒序加入目标数组，然后相应的first++,last–</li>
<li>当first &#x3D;&#x3D; last时，随便放入&gt;或者&lt;的情况即可，while也要包含这种情况。</li>
</ul>
<h4 id="我的代码-1"><a href="#我的代码-1" class="headerlink" title="我的代码"></a>我的代码</h4><h5 id="python"><a href="#python" class="headerlink" title="python"></a>python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="comment"># return sorted([x**2 for x in nums])</span></span><br><span class="line">    first,last,index = <span class="number">0</span>,<span class="built_in">len</span>(nums) - <span class="number">1</span>,<span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">    res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">    <span class="keyword">while</span> first&lt;=last:</span><br><span class="line">        <span class="keyword">if</span> nums[first]*nums[first] &lt; nums[last]*nums[last]:</span><br><span class="line">            res[index] = nums[last]*nums[last];</span><br><span class="line">            last -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            res[index] = nums[first]*nums[first];</span><br><span class="line">            first += <span class="number">1</span></span><br><span class="line">        index -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">       <span class="keyword">while</span>(first&lt;=last)&#123;</span><br><span class="line">           <span class="comment">// if(Math.pow(nums[first],2) &lt; Math.pow(nums[last],2))&#123;</span></span><br><span class="line">           <span class="comment">//     res[index] = (int)Math.pow(nums[last],2);</span></span><br><span class="line">           <span class="comment">//     last--;</span></span><br><span class="line">           <span class="comment">// &#125;else if (Math.pow(nums[first],2) &gt;= Math.pow(nums[last],2))&#123;</span></span><br><span class="line">           <span class="comment">//     res[index] = (int)Math.pow(nums[first],2);</span></span><br><span class="line">           <span class="comment">//     first++;</span></span><br><span class="line">           <span class="comment">// &#125;</span></span><br><span class="line">           <span class="keyword">if</span>(nums[first]*nums[first] &lt; nums[last]*nums[last])&#123;</span><br><span class="line">               res[index] = nums[last]*nums[last];</span><br><span class="line">               last--;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[first]*nums[first] &gt;= nums[last]*nums[last])&#123;</span><br><span class="line">               res[index] = nums[first]*nums[first];</span><br><span class="line">               first++;</span><br><span class="line">           &#125;</span><br><span class="line">           index--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>经过测试直接×的效率要高于使用Math.pow(x,a)函数。</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325015253717.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325015253717.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240325015253717"></p>
<h3 id="5、209-长度最小的子数组-3-24"><a href="#5、209-长度最小的子数组-3-24" class="headerlink" title="5、209. 长度最小的子数组(3.24)"></a>5、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a>(3.24)</h3><p>中等</p>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续</strong></p>
<p><strong>子数组</strong></p>
<p><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度<strong>。</strong>如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 4, nums = [1,4,4]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 11, nums = [1,1,1,1,1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt;= 109</code></li>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>1 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>如果你已经实现 <code>O(n)</code> 时间复杂度的解法, 请尝试设计一个 <code>O(n log(n))</code> 时间复杂度的解法。</li>
</ul>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>数组操作中另⼀个重要的⽅法：滑动窗口。<br>    所谓滑动窗口，就是不断的调节⼦序列的起始位置和终⽌位置，从⽽得出我们要想的结果。在暴⼒解法中，是⼀个for循环滑动窗口的起始位置，⼀个for循环为滑动窗口的终⽌位置，⽤两个for循环 完成了<br>    ⼀个不断搜索区间的过程。<br>那么滑动窗口如何⽤⼀个for循环来完成这个操作呢。<br>⾸先要思考 如果⽤⼀个for循环，那么应该表示 滑动窗口的起始位置，还是终⽌位置。<br>如果只⽤⼀个for循环来表示 <strong>滑动窗口的起始位置</strong>，那么如何遍历剩下的终⽌位置？<br>此时难免再次陷⼊ 暴⼒解法的怪圈。<br>所以 只⽤⼀个for循环，那么这个循环的索引，<strong>⼀定是表示 滑动窗口的终⽌位置</strong>。</p>
<p>​	其实从动画中可以发现滑动窗口也可以理解为双指针法的⼀种！只不过这种解法更像是⼀个窗口的移动，所以叫做滑动窗口更适合⼀些。<br>​	在本题中实现滑动窗口，主要确定如下三点：</p>
<ul>
<li>窗口内是什么？</li>
<li>如何移动窗口的起始位置？</li>
<li>如何移动窗口的结束位置？</li>
</ul>
<p>​	窗口就是 <strong>满足其和 ≥ s 的长度最小的 连续子数组。</strong><br>​	窗口的<strong>起始位置</strong>如何移动：<strong>如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</strong><br>​	窗口的<strong>结束位置</strong>如何移动：窗口的结束位置就是<strong>遍历数组的指针</strong>，也就是for循环里的索引。</p>
<h5 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h5><ul>
<li><p>这个思想和暴力搜索差不多，暴力搜索是选一个开始索引，然后第二个索引j去加元素，但这样是O(n^2);滑动窗口相当于是结束指针，去剔除来算最小满足条件的数组长度。</p>
</li>
<li><p>滑动窗口类似的用while好很多，for这题用来遍历数组也可以</p>
</li>
<li><p>临界条件 使用数组长度 + 1，只用后面判断是不是数组长度+1，如果是说明结果不对，不存在相应的最小数组，所以返回0</p>
</li>
</ul>
<h4 id="我的代码-2"><a href="#我的代码-2" class="headerlink" title="我的代码"></a>我的代码</h4><h5 id="python-1"><a href="#python-1" class="headerlink" title="python"></a>python</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">minSubArrayLen</span>(<span class="params">self, target: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    first,last,Sum,length = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="built_in">len</span>(nums) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> last <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">        Sum += nums[last]</span><br><span class="line">        <span class="keyword">while</span> Sum &gt;= target:</span><br><span class="line">            length = <span class="built_in">min</span>(last - first + <span class="number">1</span> ,length)</span><br><span class="line">            Sum -= nums[first]</span><br><span class="line">            first += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 有可能所有子数组求和都不满足</span></span><br><span class="line">    <span class="keyword">return</span> length <span class="keyword">if</span> length != <span class="built_in">len</span>(nums)+<span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="java-1"><a href="#java-1" class="headerlink" title="java"></a>java</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int minSubArrayLen(int target, int[] nums) &#123;</span><br><span class="line">        int first = 0;</span><br><span class="line">        int last = 0;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int leng = nums.length + 1;</span><br><span class="line">        for(;last &lt; nums.length;last++)&#123;</span><br><span class="line">            sum += nums[last];</span><br><span class="line">            while(sum&gt;=target)&#123;</span><br><span class="line">                leng = Math.min(leng,last - first + 1);</span><br><span class="line">                sum -= nums[first];</span><br><span class="line">                first++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return leng == nums.length + 1 ? 0:leng ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325015310799.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325015310799.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240325015310799"></p>
<h3 id="6、59-螺旋矩阵-II-3-24"><a href="#6、59-螺旋矩阵-II-3-24" class="headerlink" title="6、59. 螺旋矩阵 II (3.24)"></a>6、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a> (3.24)</h3><p>中等</p>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
<p><strong>示例 1：</strong></p>
<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/spiraln.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/spiraln.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img" style="zoom:67%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[[1,2,3],[8,9,4],[7,6,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
</ul>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>求解本题依然是要坚持循环不变量原则。</p>
<p><strong>每一圈都有一个起始位置startX,和startY,开始是(0,0),下面是(1,1)…</strong></p>
<p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上⾏从左到右</li>
<li>填充右列从上到下</li>
<li>填充下⾏从右到左</li>
<li>填充左列从下到上</li>
</ul>
<p>​	由外向内⼀圈⼀圈这么画下去。</p>
<p><strong>还有每次的最后一个元素不是直接到末尾，有一个偏移量offset，这个偏移量对这圈循环的最后一个限制都一样，也就是每一圈是一个固定值，比如第一圈就是1,第二圈就是2;所以也需要一个记录圈数的loop</strong></p>
<p>​	可以发现这⾥的边界条件⾮常多，在⼀个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是⼀进循环深似海，从此offer是路⼈。</p>
<p>按照<strong>左闭右开</strong>的原则，画图</p>
<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240324233335035.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240324233335035.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240324233335035" style="zoom:50%;" />

<p>​	因为每一圈都要重新画四条边，所以startX,startY,offset,loop都要改变，使用for循环不太好表示每圈的变化，因此使用while比较好。</p>
<p>​	由于给的是正方形数组的长度，一圈跑完后会少掉2行2列，因此2*x &#x3D; n;   x-&gt; n&#x2F;&#x2F;2;</p>
<p><strong>如果是奇数，刚好是中心的那个元素，直接赋值即可</strong>。</p>
<h4 id="我的代码-3"><a href="#我的代码-3" class="headerlink" title="我的代码"></a>我的代码</h4><h5 id="java-2"><a href="#java-2" class="headerlink" title="java"></a>java</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        // 按照左闭右开的原则</span><br><span class="line">        int startX = 0;</span><br><span class="line">        int startY = 0;</span><br><span class="line">        int offset = 1;</span><br><span class="line">        int loop = 0;</span><br><span class="line">        int i=0,j=0;</span><br><span class="line">        int num = 1;</span><br><span class="line">        int[][] res = new int[n][n];</span><br><span class="line">        while(loop &lt; n / 2)&#123;</span><br><span class="line">            i = startX;</span><br><span class="line">            j = startY;</span><br><span class="line">            // 上边</span><br><span class="line">            for(j=startY ;j &lt; n - offset; j++)&#123;</span><br><span class="line">                res[startX][j] = num;</span><br><span class="line">                // System.out.print(res[startX][j]);</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            //右边</span><br><span class="line">            for(i=startX ;i &lt; n - offset; i++)&#123;</span><br><span class="line">                res[i][j] = num++;</span><br><span class="line">                // System.out.println(res[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            //下边</span><br><span class="line">            for( ;j &gt; offset - 1; j--)&#123;</span><br><span class="line">                res[i][j] = num++;</span><br><span class="line">                // System.out.println(res[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            //左边</span><br><span class="line">            for(;i &gt; offset - 1; i--)&#123;</span><br><span class="line">                res[i][j] = num++;</span><br><span class="line">                // System.out.println(res[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            startX++;</span><br><span class="line">            startY++;</span><br><span class="line">            offset++;</span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line">        // System.out.println(i);</span><br><span class="line">        // System.out.println(j);</span><br><span class="line">        if(n % 2 != 0)&#123;</span><br><span class="line">            res[startX][startY] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法二：很多变量有线性关系，可以进行简化</p>
<p>startX &#x3D;&#x3D; startY,  offset &#x3D; startX + 1;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">// 简化</span><br><span class="line">    public int[][] generateMatrix(int n) &#123;</span><br><span class="line">        // 按照左闭右开的原则</span><br><span class="line">        int startXY = 0;// </span><br><span class="line">        int loop = 0;</span><br><span class="line">        int i=0,j=0;</span><br><span class="line">        int num = 1;</span><br><span class="line">        int[][] res = new int[n][n];</span><br><span class="line">        while(loop &lt; n / 2)&#123;</span><br><span class="line">            i = startXY;</span><br><span class="line">            j = startXY;</span><br><span class="line">            // 上边</span><br><span class="line">            for(j=startXY ;j &lt; n - startXY - 1; j++)&#123;</span><br><span class="line">                res[startXY][j] = num++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            //右边</span><br><span class="line">            for(i=startXY ;i &lt; n - startXY - 1; i++)&#123;</span><br><span class="line">                res[i][j] = num++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            //下边</span><br><span class="line">            for( ;j &gt; startXY ; j--)&#123;</span><br><span class="line">                res[i][j] = num++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            //左边</span><br><span class="line">            for(;i &gt; startXY; i--)&#123;</span><br><span class="line">                res[i][j] = num++;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            startXY++;</span><br><span class="line">            loop++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(n % 2 != 0)&#123;</span><br><span class="line">            res[startXY][startXY] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="python解法-两种不知道结果为啥不对，很奇怪。"><a href="#python解法-两种不知道结果为啥不对，很奇怪。" class="headerlink" title="python解法  两种不知道结果为啥不对，很奇怪。"></a>python解法  两种不知道结果为啥不对，很奇怪。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # def generateMatrix(self, n: int) -&gt; List[List[int]]:</span><br><span class="line">    #     num,loop,startXY = 1,0,0</span><br><span class="line">    #     # 创建二维空数组 [[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span><br><span class="line">    #     li = [[0 for i in range(n)] for j in range(n)]</span><br><span class="line">    #     while(loop &lt; n // 2):</span><br><span class="line">    #         i,j = startXY,startXY</span><br><span class="line">    #         # 上侧</span><br><span class="line">    #         for j in range(startXY,n - startXY - 1):</span><br><span class="line">    #             li[startXY][j]=num</span><br><span class="line">    #             num += 1</span><br><span class="line">    #         # 右侧</span><br><span class="line">    #         for i in range(startXY,n - startXY - 1):</span><br><span class="line">    #             li[i][j]=num</span><br><span class="line">    #             num += 1</span><br><span class="line">    #         print(i)</span><br><span class="line">    #         # 下侧</span><br><span class="line">    #         for j in range(i,startXY,-1):</span><br><span class="line">    #             li[i][j]=num</span><br><span class="line">    #             num += 1</span><br><span class="line">    #         # 左侧</span><br><span class="line">    #         for i in range(j,startXY,-1):</span><br><span class="line">    #             li[i][j]=num</span><br><span class="line">    #             num += 1</span><br><span class="line">    #         startXY += 1</span><br><span class="line">    #         loop += 1</span><br><span class="line">    #     if n % 2 != 0:</span><br><span class="line">    #         li[startXY][startXY] = num</span><br><span class="line">        </span><br><span class="line">    #     return li</span><br><span class="line">    def generateMatrix(self, n: int) -&gt; List[List[int]]:</span><br><span class="line">        startXY = 0</span><br><span class="line">        loop = 0</span><br><span class="line">        num = 1</span><br><span class="line">        res = [[0] * n for _ in range(n)]</span><br><span class="line">        </span><br><span class="line">        while loop &lt; n // 2:</span><br><span class="line">            i, j = startXY, startXY</span><br><span class="line">            </span><br><span class="line">            # 上边</span><br><span class="line">            for j in range(startXY, n - startXY - 1):</span><br><span class="line">                res[startXY][j] = num</span><br><span class="line">                print(res[startXY][j])</span><br><span class="line">                num += 1</span><br><span class="line">            </span><br><span class="line">            # 右边</span><br><span class="line">            for i in range(startXY, n - startXY - 1):</span><br><span class="line">                res[i][j] = num</span><br><span class="line">                print(res[i][j])</span><br><span class="line">                num += 1</span><br><span class="line">            </span><br><span class="line">            # 下边</span><br><span class="line">            for j in range(n - startXY - 1, startXY, -1):</span><br><span class="line">                print(&#x27;i,j&#x27;,i,j)</span><br><span class="line">                res[i][j] = num</span><br><span class="line">                print(res[i][j])</span><br><span class="line">                num += 1</span><br><span class="line">            </span><br><span class="line">            # 左边</span><br><span class="line">            for i in range(n - startXY - 1, startXY, -1):</span><br><span class="line">                res[i][j] = num</span><br><span class="line">                print(res[i][j])</span><br><span class="line">                num += 1</span><br><span class="line">            </span><br><span class="line">            startXY += 1</span><br><span class="line">            loop += 1</span><br><span class="line">        </span><br><span class="line">        if n % 2 != 0:</span><br><span class="line">            res[startXY][startXY] = num</span><br><span class="line">            print(res[startXY][startXY])</span><br><span class="line">        </span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325004452988.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325004452988.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240325004452988"></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325015329752.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325015329752.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240325015329752"></p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>​	python的for和java的for不一样，java的i或者j会自增到边界，而py不会，所以每次for循环需要单独加上来</p>
<p>正确结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">def generateMatrix(self, n: int) -&gt; List[List[int]]:</span><br><span class="line">    startXY = 0</span><br><span class="line">    loop = 0</span><br><span class="line">    num = 1</span><br><span class="line">    res = [[0] * n for _ in range(n)]</span><br><span class="line">    </span><br><span class="line">    while loop &lt; n // 2:</span><br><span class="line">        i, j = startXY, startXY</span><br><span class="line">        print(&#x27;Top&#x27;)</span><br><span class="line">        # 上边</span><br><span class="line">        for j in range(startXY, n - startXY - 1):</span><br><span class="line">            # print(&#x27;i,j&#x27;,i,j)</span><br><span class="line">            res[startXY][j] = num</span><br><span class="line">            print(res[startXY][j])</span><br><span class="line">            num += 1</span><br><span class="line">        j += 1</span><br><span class="line">        print(&#x27;Right&#x27;)</span><br><span class="line">        # 右边</span><br><span class="line">        for i in range(startXY, n - startXY - 1):</span><br><span class="line">            # print(&#x27;i,j&#x27;,i,j)</span><br><span class="line">            res[i][j] = num</span><br><span class="line">            print(res[i][j])</span><br><span class="line">            num += 1</span><br><span class="line">        print(&#x27;Bottom&#x27;)</span><br><span class="line">        i += 1</span><br><span class="line">        # 下边</span><br><span class="line">        for j in range(n - startXY - 1, startXY, -1):</span><br><span class="line">            # print(&#x27;i,j&#x27;,i,j)</span><br><span class="line">            res[i][j] = num</span><br><span class="line">            print(res[i][j])</span><br><span class="line">            num += 1</span><br><span class="line">        j-=1</span><br><span class="line">        print(&#x27;Left&#x27;)</span><br><span class="line">        # 左边</span><br><span class="line">        for i in range(n - startXY - 1, startXY, -1):</span><br><span class="line">            # print(&#x27;i,j&#x27;,i,j)</span><br><span class="line">            res[i][j] = num</span><br><span class="line">            print(res[i][j])</span><br><span class="line">            num += 1</span><br><span class="line">        i-=1</span><br><span class="line">        startXY += 1</span><br><span class="line">        loop += 1</span><br><span class="line">    </span><br><span class="line">    if n % 2 != 0:</span><br><span class="line">        res[startXY][startXY] = num</span><br><span class="line">        # print(res[startXY][startXY])</span><br><span class="line">    </span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h3><p>C++</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Java：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="comment">// 结点的值</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个结点</span></span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(无参)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有一个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的构造函数(有两个参数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.val = val</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">next</span> = <span class="built_in">next</span></span><br></pre></td></tr></table></figure>



<h3 id="1、203-移除链表元素-3-25"><a href="#1、203-移除链表元素-3-25" class="headerlink" title="1、203. 移除链表元素(3.25)"></a>1、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a>(3.25)</h3><p>已解答</p>
<p>简单</p>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/removelinked-list.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/removelinked-list.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [7,7,7,7], val = 7</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>列表中的节点数目在范围 <code>[0, 104]</code> 内</li>
<li><code>1 &lt;= Node.val &lt;= 50</code></li>
<li><code>0 &lt;= val &lt;= 50</code></li>
</ul>
<h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>用一个虚拟头节点放到原来的节点前面dummy_head.next&#x3D;head，这样就可以统一删除节点的逻辑,最后返回链表的时候，只用返回dummy_head.next即可</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeElements</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], val: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="comment"># 创建虚拟节点,连接到head前面</span></span><br><span class="line">        dummy_head = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        <span class="comment"># 创建临时节点</span></span><br><span class="line">        pre = dummy_head</span><br><span class="line">        <span class="keyword">while</span>(pre.<span class="built_in">next</span>!=<span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">if</span> pre.<span class="built_in">next</span>.val == val:</span><br><span class="line">                pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h4 id="java代码"><a href="#java代码" class="headerlink" title="java代码"></a>java代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val - <span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="comment">//临时指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(prev.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prev.next.val==val)&#123;</span><br><span class="line">                prev.next = prev.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = prev.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325233436166.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240325233436166.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240325233436166"></p>
<h3 id="2、707-设计链表-3-25-3-29"><a href="#2、707-设计链表-3-25-3-29" class="headerlink" title="2、707. 设计链表(3.25,3.29)"></a>2、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a>(3.25,3.29)</h3><p>中等</p>
<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针&#x2F;引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;MyLinkedList&quot;, &quot;addAtHead&quot;, &quot;addAtTail&quot;, &quot;addAtIndex&quot;, &quot;get&quot;, &quot;deleteAtIndex&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1], [3], [1, 2], [1], [1], [1]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, null, 2, null, 3]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MyLinkedList myLinkedList = new MyLinkedList();</span><br><span class="line">myLinkedList.addAtHead(1);</span><br><span class="line">myLinkedList.addAtTail(3);</span><br><span class="line">myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 2</span><br><span class="line">myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3</span><br><span class="line">myLinkedList.get(1);              // 返回 3</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= index, val &lt;= 1000</code></li>
<li>请不要使用内置的 LinkedList 库。</li>
<li>调用 <code>get</code>、<code>addAtHead</code>、<code>addAtTail</code>、<code>addAtIndex</code> 和 <code>deleteAtIndex</code> 的次数不超过 <code>2000</code> 。</li>
</ul>
<h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>显而易见的</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-1"><a href="#java代码-1" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList &#123;</span><br><span class="line">    int size;</span><br><span class="line">    ListNode head;</span><br><span class="line">    public MyLinkedList() &#123;</span><br><span class="line">        size = 0;</span><br><span class="line">        head = new ListNode(0); //虚拟头节点</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int index) &#123;</span><br><span class="line">        if(index &gt; size - 1|| index &lt; 0)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head.next;</span><br><span class="line">        // 计数，返回对应的值</span><br><span class="line">        while(index!=0)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            index -= 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return cur.val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addAtHead(int val) &#123;</span><br><span class="line"></span><br><span class="line">        ListNode node = new ListNode(val);</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        size++;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    public void addAtTail(int val) &#123;</span><br><span class="line">        </span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        while (cur.next != null) &#123; </span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = new ListNode(val);</span><br><span class="line">        cur.next = node;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    public void addAtIndex(int index, int val) &#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        if(index &gt; size)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if(index &lt; 0)&#123;</span><br><span class="line">            index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        // 添加节点需要在该节点前面,所以不能是0</span><br><span class="line">        while(index--!=0)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = new ListNode(val);</span><br><span class="line">        node.next = cur.next;</span><br><span class="line">        cur.next = node;</span><br><span class="line">        size++;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void deleteAtIndex(int index) &#123;</span><br><span class="line">        // 删除不能等于 size</span><br><span class="line">        if(index &gt;= size || index &lt; 0)&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        </span><br><span class="line">        // 添加节点需要在该节点前面</span><br><span class="line">        while(index--!=0)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        size--;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    public ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MyLinkedList object will be instantiated and called as such:</span><br><span class="line"> * MyLinkedList obj = new MyLinkedList();</span><br><span class="line"> * int param_1 = obj.get(index);</span><br><span class="line"> * obj.addAtHead(val);</span><br><span class="line"> * obj.addAtTail(val);</span><br><span class="line"> * obj.addAtIndex(index,val);</span><br><span class="line"> * obj.deleteAtIndex(index);</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h5 id="python代码-1"><a href="#python代码-1" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class MyLinkedList:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.size = 0</span><br><span class="line">        self.head = LinkNode(0)</span><br><span class="line">    def get(self, index: int) -&gt; int:</span><br><span class="line">        if (index&lt;0 or index &gt; self.size-1):</span><br><span class="line">            return -1</span><br><span class="line">        cur = self.head.next</span><br><span class="line">        while(index!=0):</span><br><span class="line">            cur = cur.next</span><br><span class="line">            index-=1</span><br><span class="line">        return cur.val</span><br><span class="line"></span><br><span class="line">    def addAtHead(self, val: int) -&gt; None:</span><br><span class="line">        node = LinkNode(val)</span><br><span class="line">        node.next = self.head.next</span><br><span class="line">        self.head.next = node</span><br><span class="line">        self.size += 1</span><br><span class="line"></span><br><span class="line">    def addAtTail(self, val: int) -&gt; None:</span><br><span class="line">        cur = self.head</span><br><span class="line">        while(cur.next!=None):</span><br><span class="line">             cur = cur.next</span><br><span class="line">        cur.next = LinkNode(val)</span><br><span class="line">        self.size+=1</span><br><span class="line"></span><br><span class="line">    def addAtIndex(self, index: int, val: int) -&gt; None:</span><br><span class="line">        if(index &gt; self.size): return</span><br><span class="line">        if(index &lt; 0): index = 0</span><br><span class="line">        cur = self.head</span><br><span class="line">        while(index!=0):</span><br><span class="line">            cur = cur.next</span><br><span class="line">            index-=1</span><br><span class="line">        # 修复了问题</span><br><span class="line">        node = LinkNode(val)</span><br><span class="line">        node.next = cur.next</span><br><span class="line">        cur.next = node</span><br><span class="line"></span><br><span class="line">        self.size+=1</span><br><span class="line"></span><br><span class="line">    def deleteAtIndex(self, index: int) -&gt; None:</span><br><span class="line">        # 对比add,delete不能等于size</span><br><span class="line">        if(index &gt;= self.size or index &lt; 0): return</span><br><span class="line">        cur = self.head</span><br><span class="line">        while(index!=0):</span><br><span class="line">            cur = cur.next</span><br><span class="line">            index-=1</span><br><span class="line">        cur.next = cur.next.next</span><br><span class="line">        self.size-=1</span><br><span class="line"></span><br><span class="line">class LinkNode:</span><br><span class="line">    def __init__(self,val=0):</span><br><span class="line">        self.val = val;</span><br><span class="line">        self.next = None;</span><br></pre></td></tr></table></figure>

<p>官方答案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class ListNode:</span><br><span class="line"></span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyLinkedList:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.size = 0</span><br><span class="line">        self.head = ListNode(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def get(self, index: int) -&gt; int:</span><br><span class="line">        if index &lt; 0 or index &gt;= self.size:</span><br><span class="line">            return -1</span><br><span class="line">        cur = self.head</span><br><span class="line">        for _ in range(index + 1):</span><br><span class="line">            cur = cur.next</span><br><span class="line">        return cur.val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def addAtHead(self, val: int) -&gt; None:</span><br><span class="line">        self.addAtIndex(0, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def addAtTail(self, val: int) -&gt; None:</span><br><span class="line">        self.addAtIndex(self.size, val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def addAtIndex(self, index: int, val: int) -&gt; None:</span><br><span class="line">        if index &gt; self.size:</span><br><span class="line">            return</span><br><span class="line">        index = max(0, index)</span><br><span class="line">        self.size += 1</span><br><span class="line">        pred = self.head</span><br><span class="line">        for _ in range(index):</span><br><span class="line">            pred = pred.next</span><br><span class="line">        to_add = ListNode(val)</span><br><span class="line">        to_add.next = pred.next</span><br><span class="line">        pred.next = to_add</span><br><span class="line"></span><br><span class="line">    def deleteAtIndex(self, index: int) -&gt; None:</span><br><span class="line">        if index &lt; 0 or index &gt;= self.size:</span><br><span class="line">            return</span><br><span class="line">        self.size -= 1</span><br><span class="line">        pred = self.head</span><br><span class="line">        for _ in range(index):</span><br><span class="line">            pred = pred.next</span><br><span class="line">        pred.next = pred.next.next</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329144404759.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329144404759.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329144404759"></p>
<h3 id="3、206-反转链表-3-25"><a href="#3、206-反转链表-3-25" class="headerlink" title="3、206. 反转链表(3.25)"></a>3、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a>(3.25)</h3><p>简单</p>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/rev1ex2.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/rev1ex2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><ul>
<li>使用双指针的思想，从头开始pre&#x3D;null和cur指针，交换位置，但是又需要cur和pre向右移动，因此需要tmp来保存cur.next的地址，反向完之后先将pre &#x3D; cur，接着 cur &#x3D; tmp，才能保证一直向右移动，直到cur是null的时候，此时pre是最后一个节点，说明链表翻转完毕。</li>
<li>在这个基础上，可以使用递归来更加简介的写出来代码。</li>
</ul>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-2"><a href="#java代码-2" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">    //     //双指针</span><br><span class="line">    //     ListNode pre = null;</span><br><span class="line">    //     ListNode cur = head;</span><br><span class="line">    //     while(cur != null)&#123;</span><br><span class="line">    //         ListNode tmp = cur.next;</span><br><span class="line">    //         cur.next = pre;</span><br><span class="line">    //         pre = cur;</span><br><span class="line">    //         cur = tmp;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return pre;</span><br><span class="line"></span><br><span class="line">    // &#125;</span><br><span class="line">	</span><br><span class="line">	// 递归</span><br><span class="line">    public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        </span><br><span class="line">        return reverse(null,head);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public ListNode reverse(ListNode pre,ListNode cur) &#123;</span><br><span class="line">        // 终止条件</span><br><span class="line">        if (cur == null)&#123;</span><br><span class="line">            return pre;</span><br><span class="line">        &#125;</span><br><span class="line">        //暂存节点</span><br><span class="line">        ListNode tmp = cur.next;</span><br><span class="line">        //开始翻转</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        //向后移动，继续翻转</span><br><span class="line">        return reverse(cur,tmp);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-2"><a href="#python代码-2" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, val=0, next=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.next = next</span><br><span class="line">class Solution:</span><br><span class="line">    # 非递归——双指针</span><br><span class="line"></span><br><span class="line">    # def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span><br><span class="line">    #     # pre = ListNode(next=None)</span><br><span class="line">    #     pre = None</span><br><span class="line">    #     cur = head</span><br><span class="line">    #     while(cur != None):</span><br><span class="line">    #         tmp = cur.next</span><br><span class="line">    #         cur.next = pre</span><br><span class="line">    #         pre = cur</span><br><span class="line">    #         cur = tmp</span><br><span class="line">    #     return pre</span><br><span class="line"></span><br><span class="line">    # 递归</span><br><span class="line">    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:</span><br><span class="line">        def reverse(pre,cur):</span><br><span class="line">            # 终止条件</span><br><span class="line">            if cur == None:</span><br><span class="line">                return pre</span><br><span class="line">            tmp = cur.next</span><br><span class="line">            cur.next = pre</span><br><span class="line">            # reverse(cur,tmp)  记得返回值</span><br><span class="line">            return reverse(cur,tmp)</span><br><span class="line">        return reverse(None,head)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240326000656533.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240326000656533.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240326000656533"></p>
<h3 id="4、24-两两交换链表中的节点-3-28"><a href="#4、24-两两交换链表中的节点-3-28" class="headerlink" title="4、24. 两两交换链表中的节点(3.28)"></a>4、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a>(3.28)</h3><p>中等</p>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/swap_ex1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/swap_ex1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>其实比较简单</p>
<p>使用虚拟头结点使得交换的逻辑保持一致，依次交换两个元素，<strong>此时⼀定要画图，不画图，操作多个指针很容易乱，⽽且要操作的先后顺序。</strong><br><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240328233810500.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240328233810500.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240328233810500"></p>
<p>操作之后，链表如下：</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240328233855892.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240328233855892.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240328233855892"></p>
<p>核心是要暂存一些指针，因为改变链接顺序后会导致有些连接无法继续，比如步骤一采取后指针一就无法被继续使用，步骤二采取后，指针3就无法继续使用，因此需要暂存的指针就是tmp &#x3D; cur-&gt;next, tmp1 &#x3D; cur-&gt;next-&gt;next;</p>
<p>结束条件，如果是偶数个，cur-&gt;next&#x3D;null,刚好结束,奇数个cur-&gt;next-&gt;next&#x3D;null也结束，也需要保持顺序。</p>
<h4 id="我的代码-4"><a href="#我的代码-4" class="headerlink" title="我的代码"></a>我的代码</h4><h5 id="java代码-3"><a href="#java代码-3" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 1.非递归</span><br><span class="line"></span><br><span class="line">    // public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">    //     // 添加虚拟头节点</span><br><span class="line">    //     ListNode dummy = new ListNode(0);</span><br><span class="line">    //     dummy.next = head;</span><br><span class="line">    //     ListNode cur = dummy;</span><br><span class="line">    //     // 偶数个，奇数个    java中短路&amp; 如果前面是False就不会执行后面的，也就不会出现空指针异常</span><br><span class="line">    //     while(cur.next!=null &amp;&amp; cur.next.next!=null)&#123;</span><br><span class="line">    //         // 1</span><br><span class="line">    //         ListNode tmp = cur.next;</span><br><span class="line">    //         // 3</span><br><span class="line">    //         ListNode tmp1 = cur.next.next.next;</span><br><span class="line">    //         // 2</span><br><span class="line">    //         cur.next = cur.next.next;</span><br><span class="line">    //         // 1</span><br><span class="line">    //         cur.next.next = tmp;</span><br><span class="line">    //         // 3</span><br><span class="line">    //         cur.next.next.next = tmp1;</span><br><span class="line">    //         // 要修改的是3，4，所以cur要转移到cur.next.next</span><br><span class="line">    //         cur = cur.next.next;</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return dummy.next;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    //2.递归</span><br><span class="line"></span><br><span class="line">        public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        // 添加虚拟头节点</span><br><span class="line">        ListNode dummy = new ListNode(0);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        swap(cur);</span><br><span class="line">        return dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void swap(ListNode cur)&#123;</span><br><span class="line">        if(cur.next==null || cur.next.next==null)&#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">        // 1</span><br><span class="line">        ListNode tmp = cur.next;</span><br><span class="line">        // 3</span><br><span class="line">        ListNode tmp1 = cur.next.next.next;</span><br><span class="line">        // 2</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        // 1</span><br><span class="line">        cur.next.next = tmp;</span><br><span class="line">        // 3</span><br><span class="line">        cur.next.next.next = tmp1;</span><br><span class="line">        // 要修改的是3，4，所以cur要转移到cur.next.next</span><br><span class="line">        swap(cur.next.next);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3.官网递归(更简洁)</span><br><span class="line">    </span><br><span class="line">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class="line">        if (head == null || head.next == null) &#123;</span><br><span class="line">            return head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newHead = head.next;</span><br><span class="line">        head.next = swapPairs(newHead.next);</span><br><span class="line">        newHead.next = head;</span><br><span class="line">        return newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-3"><a href="#python代码-3" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode();</span><br><span class="line">        dummy.<span class="built_in">next</span> = head;</span><br><span class="line">        cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>):</span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            tmp1 = cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> =  cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span> = tmp</span><br><span class="line">            cur.<span class="built_in">next</span>.<span class="built_in">next</span>.<span class="built_in">next</span> = tmp1</span><br><span class="line">            <span class="comment"># 移动到tmp1位置</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329001637897.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329001637897.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329001637897"></p>
<h3 id="5、19-删除链表的倒数第-N-个结点-3-28"><a href="#5、19-删除链表的倒数第-N-个结点-3-28" class="headerlink" title="5、19. 删除链表的倒数第 N 个结点(3.28)"></a>5、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a>(3.28)</h3><p>中等</p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/remove_ex1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/remove_ex1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>想要删除倒数第n个必须要cur指向倒数n+1个，因此可以用双指针，当fast指向null,slow指向的就是倒数n+1，只需简单操作就可以删除倒数第n个。</p>
<p><strong>注意可能会操作空指针</strong></p>
<h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-4"><a href="#java代码-4" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode() &#123;&#125;</span><br><span class="line"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        // 添加虚拟头节点</span><br><span class="line">        ListNode dummy = new ListNode(n);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode fast = dummy;</span><br><span class="line">        ListNode slow = dummy;</span><br><span class="line">        //指向n+1</span><br><span class="line">        n++;</span><br><span class="line">        // fast先走n+1步</span><br><span class="line">        while(n-- != 0&amp;fast!=null)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        // 接着fast,slow一块移动</span><br><span class="line">        while(fast!=null)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        return dummy.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-4"><a href="#python代码-4" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], n: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        dummy = ListNode()</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        fast = dummy</span><br><span class="line">        slow = dummy</span><br><span class="line">        n+=<span class="number">1</span></span><br><span class="line">        <span class="comment"># 前移动n+1</span></span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span> <span class="keyword">and</span> fast!=<span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            n-=<span class="number">1</span></span><br><span class="line">        <span class="comment">#共同移动，fast到末尾</span></span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">None</span>):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = slow.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329003630307.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329003630307.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329003630307"></p>
<h3 id="6、142-环形链表-II-3-29"><a href="#6、142-环形链表-II-3-29" class="headerlink" title="6、142. 环形链表 II(3.29)"></a>6、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a>(3.29)</h3><p>已解答</p>
<p>中等</p>
<p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p><strong>不允许修改</strong> 链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/circularlinkedlist.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/circularlinkedlist.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" class="lazyload" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" class="lazyload" data-srcset="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围在范围 <code>[0, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li>
</ul>
<p><strong>进阶：</strong>你是否可以使用 <code>O(1)</code> 空间解决此题？</p>
<h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329005400379.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329005400379.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329005400379"></p>
<h5 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h5><p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329115212301.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329115212301.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329115212301"></p>
<p>其实，不管有没有慢指针的k圈，得到入环的节点都不会变。</p>
<h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><h5 id="python代码-5"><a href="#python代码-5" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode]</span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">    fast = head</span><br><span class="line">    slow = head</span><br><span class="line">    <span class="comment"># 要使用.next.next就要确保fast,fast.next不为None</span></span><br><span class="line">    <span class="keyword">while</span>(fast <span class="keyword">and</span> fast.<span class="built_in">next</span>):</span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 相遇之后，重新设置指针进行跑</span></span><br><span class="line">        <span class="keyword">if</span> fast <span class="keyword">is</span> slow:</span><br><span class="line">            last = head</span><br><span class="line">            <span class="comment"># 设置head和slow一块跑相遇就是环的起点</span></span><br><span class="line">            <span class="keyword">while</span>(last <span class="keyword">is</span> <span class="keyword">not</span> slow):</span><br><span class="line">                last = last.<span class="built_in">next</span></span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> slow</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h5 id="java代码-5"><a href="#java代码-5" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="literal">null</span> &amp;&amp; fast.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329120224789.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329120224789.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329120224789"></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>⼀般哈希表都是⽤来快速判断⼀个元素是否出现集合⾥。</p>
<h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数，把学⽣的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校⾥了。<br>哈希函数如下图所示，通过hashCode把名字转化为数值，⼀般hashcode是通过特定编码⽅式，可以将其他数据格式转化为不同的数值，这样就把学⽣名字映射为哈希表上的索引数字了。</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329235718577.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329235718577.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329235718577"></p>
<p>如果hashCode得到的数值⼤于 哈希表的⼤⼩了，也就是⼤于tableSize了，怎么办呢？<br>此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做⼀个取模的操作，就要我们就保证了学⽣姓名⼀定可以映射到哈希表上了。<br>此时问题⼜来了，哈希表我们刚刚说过，就是⼀个数组。<br>如果学⽣的数量⼤于哈希表的⼤⼩怎么办，此时就算哈希函数计算的再均匀，也避免不了会有⼏位学⽣的名字同时映射到哈希表 同⼀个索引下标的位置。<br>接下来哈希碰撞登场</p>
<h4 id="哈希碰撞"><a href="#哈希碰撞" class="headerlink" title="哈希碰撞"></a>哈希碰撞</h4><p>如图所示，⼩李和⼩王都映射到了索引下标 1 的位置，这⼀现象叫做哈希碰撞。</p>
<p>⼀般哈希碰撞有两种解决⽅法， 拉链法和线性探测法。</p>
<h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p>刚刚⼩李和⼩王在索引1的位置发⽣了冲突，发⽣冲突的元素都被存储在链表中。 这样我们就可以通过索引找到⼩李和⼩王了</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329235757908.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329235757908.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329235757908"></p>
<p>其实拉链法就是要选择适当的哈希表的⼤⼩，这样既不会因为数组空值⽽浪费⼤量内存，也不会因为链表太⻓⽽在查找上浪费太多时间。</p>
<p>线性探测法<br>使⽤线性探测法，⼀定要保证tableSize⼤于dataSize。 我们需要依靠哈希表中的空位来解决碰撞问题。<br>例如冲突的位置，放了⼩李，那么<strong>就向下找⼀个空位放置⼩王的信息</strong>。所以<strong>要求tableSize⼀定要⼤于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。</strong>如图所示：</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329235837518.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329235837518.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329235837518"></p>
<p>常⻅的三种哈希结构<br>当我们想使⽤哈希法来解决问题的时候，我们⼀般会选择如下三种数据结构。</p>
<ul>
<li>数组</li>
<li>set （集合）</li>
<li>map(映射)</li>
</ul>
<p>C++</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329235918951.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240329235918951.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240329235918951"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​	总结⼀下，当我们遇到了要快速判断⼀个元素是否出现集合⾥的时候，就要考虑哈希法。<br>但是哈希法也是牺牲了空间换取了时间，因为我们要使⽤额外的数组，set或者是map来存放数据，才能实现快速的查找。<br>​	如果在做⾯试题⽬的时候遇到<strong>需要判断⼀个元素是否出现过的场景</strong>也应该第⼀时间想到哈希法！</p>
<h3 id="1、242-有效的字母异位词-3-29"><a href="#1、242-有效的字母异位词-3-29" class="headerlink" title="1、242. 有效的字母异位词(3.29)"></a>1、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/">242. 有效的字母异位词</a>(3.29)</h3><p>已解答</p>
<p>简单</p>
<p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p>
<p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>
<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>
</ul>
<p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
<h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>使用数组进行哈希表映射，使用map,set等</p>
<p>使用Counter转化哈希表</p>
<h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><h5 id="python代码-6"><a href="#python代码-6" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">       <span class="comment"># 1.使用数组来做哈希表，进行映射</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># if len(s) != len(t):</span></span><br><span class="line">       <span class="comment">#     return False</span></span><br><span class="line">       <span class="comment"># # Python 代码使用 collections.defaultdict() 类，可指定所有 key 对应的默认 value 。</span></span><br><span class="line">       <span class="comment"># dic = defaultdict(int) #int 默认值是0</span></span><br><span class="line">       <span class="comment"># for i in s:</span></span><br><span class="line">       <span class="comment">#     dic[i] += 1</span></span><br><span class="line">       <span class="comment"># for i in t:</span></span><br><span class="line">       <span class="comment">#     dic[i] -= 1</span></span><br><span class="line">       <span class="comment"># for i in dic.values():</span></span><br><span class="line">       <span class="comment">#     if i!=0: return False</span></span><br><span class="line">       <span class="comment"># return True</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 2.使用Counter转化哈希表</span></span><br><span class="line">       <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">       <span class="comment"># 转化为哈希表</span></span><br><span class="line">       c = Counter(t)</span><br><span class="line">       <span class="built_in">print</span>(c)</span><br><span class="line">       <span class="comment"># 遍历t</span></span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">           c[i] -= <span class="number">1</span></span><br><span class="line">           <span class="built_in">print</span>(c[i])</span><br><span class="line">           <span class="comment"># 默认值是0</span></span><br><span class="line">           <span class="keyword">if</span> c[i] == -<span class="number">1</span>:</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="java代码-6"><a href="#java代码-6" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> s.length(), len2 = t.length();</span><br><span class="line">        <span class="keyword">if</span> (len1 != len2)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            dic.put(s.charAt(i) , dic.getOrDefault(s.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">            dic.put(t.charAt(i) , dic.getOrDefault(t.charAt(i), <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : dic.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240330004438160.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240330004438160.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240330004438160"></p>
<h3 id="2、349-两个数组的交集-3-30"><a href="#2、349-两个数组的交集-3-30" class="headerlink" title="2、349. 两个数组的交集(3.30)"></a>2、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/">349. 两个数组的交集</a>(3.30)</h3><p>简单</p>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 它们的 交集</p>
<p> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br><span class="line">解释：[4,9] 也是可通过的</span><br></pre></td></tr></table></figure>

<h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>要找交集还要去重，用set去做，所以要先把nums1变成set哈希，交集结果res也要用set哈希，最后遍历nums2去查找nums1里面是否存在，如果存在加入res里面。</p>
<h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><h5 id="python代码-7"><a href="#python代码-7" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        nums1 = <span class="built_in">set</span>(nums1)</span><br><span class="line">        res = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">                res.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(res)</span><br></pre></td></tr></table></figure>

<h5 id="java代码-7"><a href="#java代码-7" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">       Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;();</span><br><span class="line">       Set&lt;Integer&gt; res = new HashSet&lt;Integer&gt;();</span><br><span class="line">       </span><br><span class="line">       for(int n : nums1)&#123;</span><br><span class="line">           s.add(n);</span><br><span class="line">       &#125;</span><br><span class="line">       for(int i:nums2)&#123;</span><br><span class="line">           if(s.contains(i))&#123;</span><br><span class="line">               res.add(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       int[] intersection = new int[res.size()];</span><br><span class="line">       int index = 0;</span><br><span class="line">       for(int i:res)&#123;</span><br><span class="line">          intersection[index++] = i;</span><br><span class="line">       &#125;</span><br><span class="line">       return intersection;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240331004913907.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240331004913907.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240331004913907"></p>
<h3 id="3、1-两数之和-3-30"><a href="#3、1-两数之和-3-30" class="headerlink" title="3、1. 两数之和(3.30)"></a>3、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a>(3.30)</h3><p>已解答</p>
<p>简单</p>
<p>提示</p>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>查找元素是否出现过-&gt;哈希表，可以用map存值和对应索引，set存值，然后返回的时候去查索引</p>
<h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><h5 id="python代码-8"><a href="#python代码-8" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">    # set不行，如果有重复的元素</span><br><span class="line">    s = &#123;&#125;</span><br><span class="line">    # for i,v in enumerate(nums):</span><br><span class="line">    #     if target - v  in s:</span><br><span class="line">    #         return i,s[target - v]</span><br><span class="line">    #     s[v] = i</span><br><span class="line">    # return None</span><br><span class="line"></span><br><span class="line">    for i in range(len(nums)):</span><br><span class="line">        if target - nums[i]  in s:</span><br><span class="line">            return i,s[target - nums[i]]</span><br><span class="line">        s[nums[i]] = i</span><br><span class="line">    return None</span><br></pre></td></tr></table></figure>

<h5 id="java代码-8"><a href="#java代码-8" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,(<span class="type">int</span>)map.get(target - nums[i])&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240331002329095.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240331002329095.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240331002329095"></p>
<h3 id="4、454-四数相加-II-3-30"><a href="#4、454-四数相加-II-3-30" class="headerlink" title="4、454. 四数相加 II(3.30)"></a>4、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/">454. 四数相加 II</a>(3.30)</h3><p>中等</p>
<p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">两个元组如下：</span><br><span class="line">1. (0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<h4 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h4><p>A+B，C+D当成两数之和处理，如果A,B+C+D时间复杂度会高很多。</p>
<p>map，记录次数</p>
<h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><h5 id="python代码-9"><a href="#python代码-9" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -&gt; int:</span><br><span class="line">    # 给个默认值0，不然d1[i+j] += 1会因为键值对 i+j不存在报错</span><br><span class="line">    d1 = defaultdict(int)</span><br><span class="line">    res = 0</span><br><span class="line">    for i in nums1:</span><br><span class="line">        for j in nums2:</span><br><span class="line">            d1[i+j] += 1</span><br><span class="line">    for i in nums3:</span><br><span class="line">        for j in nums4:</span><br><span class="line">            # 这里其实不用判断，因为默认是0，直接加就行</span><br><span class="line">            # if d1[0 - i-j] != 0:</span><br><span class="line">            # if 0 - i-j in d1:</span><br><span class="line">            res += d1[0 - i-j]</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>

<h5 id="java代码-9"><a href="#java代码-9" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; s = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b : nums2)&#123;</span><br><span class="line">                s.put(a+b,s.getOrDefault(a+b,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a : nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b : nums4)&#123;</span><br><span class="line">                <span class="comment">// if(s.containsKey(-a-b))&#123;</span></span><br><span class="line">                <span class="comment">//     ans += s.get(-a-b);</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// 不用判断，更快</span></span><br><span class="line">                ans += s.getOrDefault(-a-b,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="5、15-三数之和-3-31"><a href="#5、15-三数之和-3-31" class="headerlink" title="5、15. 三数之和(3.31)"></a>5、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/">15. 三数之和</a>(3.31)</h3><p>已解答</p>
<p>中等</p>
<p>提示</p>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure>

<h4 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h4><h5 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h5><p>难，不推荐</p>
<h5 id="排序加双指针"><a href="#排序加双指针" class="headerlink" title="排序加双指针"></a>排序加双指针</h5><p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240401002918818.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240401002918818.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240401002918818"></p>
<p>​	拿这个nums数组来举例，⾸先将数组排序，然后有⼀层for循环，i从下标0的地⽅开始，同时定⼀个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。<br>依然还是在数组中找到 abc 使得a + b +c &#x3D;0，我们这⾥相当于 a &#x3D; nums[i]，b &#x3D; nums[left]，c &#x3D; nums[right]。<br>​	接下来如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] &gt; 0 就说明 此时三数之和⼤了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和⼩⼀些。<br>​	如果 nums[i] + nums[left] + nums[right] &lt; 0 说明 此时 三数之和⼩了，left 就向右移动，才能让三数之和⼤⼀些，直到left与right相遇为⽌。</p>
<h4 id="去重逻辑"><a href="#去重逻辑" class="headerlink" title="去重逻辑"></a>去重逻辑</h4><h5 id="a的去重"><a href="#a的去重" class="headerlink" title="a的去重"></a>a的去重</h5><p>说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 nums[i]，nums[left]，nums[right]</p>
<p>a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。</p>
<p>但这里有一个问题，<strong>是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。</strong></p>
<p>有同学可能想，这不都一样吗。</p>
<p>其实不一样！</p>
<p>都是和 nums[i]进行比较，是比较它的前一个，还是比较它的后一个。</p>
<p>如果我们的写法是 这样：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (nums[i] == nums[i + 1]) &#123; // 去重操作</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。</p>
<p><strong>我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！</strong></p>
<p>所以这里是有两个重复的维度。</p>
<p>那么应该这么写：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;</span><br><span class="line">    continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。</p>
<p>这是一个非常细节的思考过程。</p>
<h5 id="b与c的去重"><a href="#b与c的去重" class="headerlink" title="#b与c的去重"></a><a target="_blank" rel="noopener" href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html#b%E4%B8%8Ec%E7%9A%84%E5%8E%BB%E9%87%8D">#</a>b与c的去重</h5><p>很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">while (right &gt; left) &#123;</span><br><span class="line">    if (nums[i] + nums[left] + nums[right] &gt; 0) &#123;</span><br><span class="line">        right--;</span><br><span class="line">        // 去重 right</span><br><span class="line">        while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</span><br><span class="line">    &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123;</span><br><span class="line">        left++;</span><br><span class="line">        // 去重 left</span><br><span class="line">        while (left &lt; right &amp;&amp; nums[left] == nums[left - 1]) left++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但细想一下，这种去重其实对提升程序运行效率是没有帮助的。</p>
<p>拿right去重为例，即使不加这个去重逻辑，依然根据 <code>while (right &gt; left)</code> 和 <code>if (nums[i] + nums[left] + nums[right] &gt; 0)</code> 去完成right– 的操作。</p>
<p>多加了 <code>while (left &lt; right &amp;&amp; nums[right] == nums[right + 1]) right--;</code> 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。</p>
<p>最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。</p>
<p>所以这种去重是可以不加的。 仅仅是把去重的逻辑提前了而已。</p>
<h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-10"><a href="#java代码-10" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">	// 找出a + b + c = 0</span><br><span class="line">        // a = nums[i], b = nums[left], c = nums[right]</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">	    // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了</span><br><span class="line">            if (nums[i] &gt; 0) &#123; </span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;  // 去重a</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            while (right &gt; left) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if (sum &gt; 0) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125; else if (sum &lt; 0) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">		    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span><br><span class="line">                    while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="line">                    while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line">                    </span><br><span class="line">                    right--; </span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="python代码-10"><a href="#python代码-10" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 如果第一个元素已经大于0，不需要进一步检查</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 跳过相同的元素以避免重复</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> right &gt; left:</span><br><span class="line">                sum_ = nums[i] + nums[left] + nums[right]</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> sum_ &lt; <span class="number">0</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum_ &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment"># 跳过相同的元素以避免重复</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right] == nums[right - <span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[left] == nums[left + <span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                        </span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h5 id="python使用哈希表"><a href="#python使用哈希表" class="headerlink" title="python使用哈希表"></a>python使用哈希表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def threeSum(self, nums: List[int]) -&gt; List[List[int]]:</span><br><span class="line">        result = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        # 找出a + b + c = 0</span><br><span class="line">        # a = nums[i], b = nums[j], c = -(a + b)</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            # 排序之后如果第一个元素已经大于零，那么不可能凑成三元组</span><br><span class="line">            if nums[i] &gt; 0:</span><br><span class="line">                break</span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i - 1]: #三元组元素a去重</span><br><span class="line">                continue</span><br><span class="line">            d = &#123;&#125;</span><br><span class="line">            for j in range(i + 1, len(nums)):</span><br><span class="line">                if j &gt; i + 2 and nums[j] == nums[j-1] == nums[j-2]: # 三元组元素b去重</span><br><span class="line">                    continue</span><br><span class="line">                c = 0 - (nums[i] + nums[j])</span><br><span class="line">                if c in d:</span><br><span class="line">                    result.append([nums[i], nums[j], c])</span><br><span class="line">                    d.pop(c) # 三元组元素c去重</span><br><span class="line">                else:</span><br><span class="line">                    d[nums[j]] = j</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240401003842790.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240401003842790.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240401003842790"></p>
<h3 id="6、18-四数之和-3-31"><a href="#6、18-四数之和-3-31" class="headerlink" title="6、18. 四数之和 (3.31)"></a>6、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/">18. 四数之和</a> (3.31)</h3><p>中等</p>
<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>

<h4 id="思路-13"><a href="#思路-13" class="headerlink" title="思路"></a>思路</h4><p>和三数之和类似，多加了一个外层的k</p>
<h5 id="排序加双指针-1"><a href="#排序加双指针-1" class="headerlink" title="排序加双指针"></a>排序加双指针</h5><p>k,i   left,right </p>
<p>但是有⼀些细节需要注意，例如： 不要判断nums[k] &gt; target 就返回了，三数之和 可以通过 nums[i] &gt; 0 就返回了，因为 0 已经是确定的数了，四数之和这道题⽬ target是任意值。⽐如：数组是[-4, -3, -2, -1] ， target 是-10 ，不能因为-4 &gt; -10 ⽽跳过。但是我们依旧可以去做剪枝，逻辑变成nums[i] &gt; target &amp;&amp; (nums[i] &gt;&#x3D;0 || target &gt;&#x3D; 0) 就可以了。</p>
<p>15.三数之和的双指针解法是⼀层for循环num[i]为确定值，然后循环内有left和right下标作为双指针，找到nums[i] +nums[left] + nums[right] &#x3D;&#x3D; 0。<br>四数之和的双指针解法是两层for循环nums[k] + nums[i]为确定值，依然是循环内有left和right下标作为双指针，找出nums[k] + nums[i] + nums[left] + nums[right] &#x3D;&#x3D; target的情况，三数之和的时间复杂度是O(n^2)，四数之和的时间复杂度是O(n^3) 。<br>    那么⼀样的道理，五数之和、六数之和等等都采⽤这种解法。<br>对于15.三数之和双指针法就是将原本暴⼒O(n^3)的解法，降为O(n^2)的解法，四数之和的双指针解法就是将原本暴⼒O(n^4)的解法，降为O(n^3)的解法。<br>之前我们讲过哈希表的经典题⽬：454.四数相加II，相对于本题简单很多，因为本题是要求在⼀个集合中找出四个数相加等于target，同时四元组不能重复。<br>    ⽽454.四数相加II是四个独⽴的数组，只要找到A[i] + B[j] + C[k] + D[l] &#x3D; 0就可以，不⽤考虑有重复的四个元素相加等于0的情况，所以相对于本题还是简单了不少！</p>
<h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-11"><a href="#java代码-11" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">       </span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">		</span><br><span class="line">            // nums[i] &gt; target 直接返回, 剪枝操作</span><br><span class="line">            if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">		</span><br><span class="line">            if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) &#123;    // 对nums[i]去重</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            for (int j = i + 1; j &lt; nums.length; j++) &#123;</span><br><span class="line"></span><br><span class="line">                if (j &gt; i + 1 &amp;&amp; nums[j - 1] == nums[j]) &#123;  // 对nums[j]去重</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                int left = j + 1;</span><br><span class="line">                int right = nums.length - 1;</span><br><span class="line">                while (right &gt; left) &#123;</span><br><span class="line">		    // nums[k] + nums[i] + nums[left] + nums[right] &gt; target int会溢出</span><br><span class="line">                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                    if (sum &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125; else if (sum &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));</span><br><span class="line">                        // 对nums[left]和nums[right]去重</span><br><span class="line">                        while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) right--;</span><br><span class="line">                        while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) left++;</span><br><span class="line"></span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-11"><a href="#python代码-11" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        n = len(nums)</span><br><span class="line">        result = []</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if nums[i] &gt; target and nums[i] &gt; 0 and target &gt; 0:# 剪枝（可省）</span><br><span class="line">                break</span><br><span class="line">            if i &gt; 0 and nums[i] == nums[i-1]:# 去重</span><br><span class="line">                continue</span><br><span class="line">            for j in range(i+1, n):</span><br><span class="line">                if nums[i] + nums[j] &gt; target and target &gt; 0: #剪枝（可省）</span><br><span class="line">                    break</span><br><span class="line">                if j &gt; i+1 and nums[j] == nums[j-1]: # 去重</span><br><span class="line">                    continue</span><br><span class="line">                left, right = j+1, n-1</span><br><span class="line">                while left &lt; right:</span><br><span class="line">                    s = nums[i] + nums[j] + nums[left] + nums[right]</span><br><span class="line">                    if s == target:</span><br><span class="line">                        result.append([nums[i], nums[j], nums[left], nums[right]])</span><br><span class="line">                        while left &lt; right and nums[left] == nums[left+1]:</span><br><span class="line">                            left += 1</span><br><span class="line">                        while left &lt; right and nums[right] == nums[right-1]:</span><br><span class="line">                            right -= 1</span><br><span class="line">                        left += 1</span><br><span class="line">                        right -= 1</span><br><span class="line">                    elif s &lt; target:</span><br><span class="line">                        left += 1</span><br><span class="line">                    else:</span><br><span class="line">                        right -= 1</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>



<h5 id="python哈希表"><a href="#python哈希表" class="headerlink" title="python哈希表"></a>python哈希表</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def fourSum(self, nums, target):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type nums: List[int]</span><br><span class="line">        :type target: int</span><br><span class="line">        :rtype: List[List[int]]</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 创建一个字典来存储输入列表中每个数字的频率</span><br><span class="line">        freq = &#123;&#125;</span><br><span class="line">        for num in nums:</span><br><span class="line">            freq[num] = freq.get(num, 0) + 1</span><br><span class="line">        </span><br><span class="line">        # 创建一个集合来存储最终答案，并遍历4个数字的所有唯一组合</span><br><span class="line">        ans = set()</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            for j in range(i + 1, len(nums)):</span><br><span class="line">                for k in range(j + 1, len(nums)):</span><br><span class="line">                    val = target - (nums[i] + nums[j] + nums[k])</span><br><span class="line">                    if val in freq:</span><br><span class="line">                        # 确保没有重复</span><br><span class="line">                        count = (nums[i] == val) + (nums[j] == val) + (nums[k] == val)</span><br><span class="line">                        if freq[val] &gt; count:</span><br><span class="line">                            ans.add(tuple(sorted([nums[i], nums[j], nums[k], val])))</span><br><span class="line">        </span><br><span class="line">        return [list(x) for x in ans]</span><br></pre></td></tr></table></figure>



<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1、344-反转字符串-4-2"><a href="#1、344-反转字符串-4-2" class="headerlink" title="1、344. 反转字符串 (4.2)"></a>1、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a> (4.2)</h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须**<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = [&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 105</code></li>
<li><code>s[i]</code> 都是 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符</li>
</ul>
<h4 id="思路-14"><a href="#思路-14" class="headerlink" title="思路"></a>思路</h4><p>双指针，left,right，一个头一个尾，用while left &lt; right</p>
<p>for 循环 left &lt; length &#x2F; 2</p>
<p>比如长度是4，遍历到索引为1&lt; 4&#x2F;2 &#x3D; 2</p>
<p>长度是5，遍历到索引为1&lt; 5&#x2F;2 &#x3D; 2</p>
<h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><p>python代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseString(self, s: List[str]) -&gt; None:</span><br><span class="line">        left = 0</span><br><span class="line">        right = len(s) - 1</span><br><span class="line">        while left &lt; right:</span><br><span class="line">            s[left], s[right] = s[right], s[left]</span><br><span class="line">            left += 1</span><br><span class="line">            right -= 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; left++, right--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">// 字符型</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240402234331956.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240402234331956.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="2"></p>
<h3 id="2、541-反转字符串-II-4-3"><a href="#2、541-反转字符串-II-4-3" class="headerlink" title="2、541. 反转字符串 II(4.3)"></a>2、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-string-ii/">541. 反转字符串 II</a>(4.3)</h3><p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出：&quot;bacdfeg&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, k = 2</span><br><span class="line">输出：&quot;bacd&quot;</span><br></pre></td></tr></table></figure>

<h4 id="思路-15"><a href="#思路-15" class="headerlink" title="思路"></a>思路</h4><p>模拟，每次递增2k </p>
<h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-12"><a href="#java代码-12" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String reverseStr(String s, int k) &#123;</span><br><span class="line">        char[] cs = s.toCharArray();</span><br><span class="line">        int n = s.length();</span><br><span class="line">        for (int l = 0; l &lt; n; l = l + 2 * k) &#123;</span><br><span class="line">            int r = l + k - 1;</span><br><span class="line">            reverse(cs, l, Math.min(r, n - 1));</span><br><span class="line">        &#125;</span><br><span class="line">        // 返回参数类型的表现形式。</span><br><span class="line">        return String.valueOf(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    void reverse(char[] cs, int l, int r) &#123;</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            char c = cs[l];</span><br><span class="line">            cs[l] = cs[r];</span><br><span class="line">            cs[r] = c;</span><br><span class="line">            l++; r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> num,left,right;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cs.length;i+=<span class="number">2</span>*k)&#123;</span><br><span class="line">            num = Math.min(i+k,cs.length);</span><br><span class="line">            left = i;</span><br><span class="line">            right = num - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> cs[left];</span><br><span class="line">                cs[left] = cs[right];</span><br><span class="line">                cs[right] = ch;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="python代码-12"><a href="#python代码-12" class="headerlink" title="python代码"></a>python代码</h5><p>1.python的range可以设置步长，实现2k的循环<br>2.当最后一步剩余元素小于2k，超过k时，因为循环的是i，而且都是处理i后元素，i在循环不满足条件结束之前，便处理了反转k个元素<br>3.当最后剩余元素小于k时，ss[i: i+k]只会表达到ss截止的地方，不会继续往后查找，就像ss[:]表示的是从最开始项到最后项一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseStr(self, s: str, k: int) -&gt; str:</span><br><span class="line">        ss = [i for i in s]</span><br><span class="line">        n=len(s)</span><br><span class="line">        for i in range(0,n,2*k):</span><br><span class="line">            ss[i:i+k]=ss[i:i+k][::-1]</span><br><span class="line">        return &quot;&quot;.join(ss)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseStr(self, s: str, k: int) -&gt; str:</span><br><span class="line">        li = [i for i in s]</span><br><span class="line">        for i in range(0,len(s),2*k):</span><br><span class="line">            t = min(i+k,len(s))</span><br><span class="line">            li[i:t] = li[i:t][::-1]</span><br><span class="line">        return &#x27;&#x27;.join(li)</span><br></pre></td></tr></table></figure>

<h3 id="3、151-反转字符串中的单词-4-3"><a href="#3、151-反转字符串中的单词-4-3" class="headerlink" title="3、151. 反转字符串中的单词(4.3)"></a>3、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-words-in-a-string/">151. 反转字符串中的单词</a>(4.3)</h3><p>中等</p>
<p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p><strong>注意：</strong>输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;the sky is blue&quot;</span><br><span class="line">输出：&quot;blue is sky the&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;  hello world  &quot;</span><br><span class="line">输出：&quot;world hello&quot;</span><br><span class="line">解释：反转后的字符串中不能存在前导空格和尾随空格。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a good   example&quot;</span><br><span class="line">输出：&quot;example good a&quot;</span><br><span class="line">解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 包含英文大小写字母、数字和空格 <code>&#39; &#39;</code></li>
<li><code>s</code> 中 <strong>至少存在一个</strong> 单词</li>
</ul>
<p><strong>进阶：</strong>如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 <code>O(1)</code> 额外空间复杂度的 <strong>原地</strong> 解法。</p>
<h4 id="思路-16"><a href="#思路-16" class="headerlink" title="思路"></a>思路</h4><p>双指针+移除空格</p>
<h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-13"><a href="#java代码-13" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用Java内置方法实现</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 1.去除首尾以及中间多余空格</span></span><br><span class="line"><span class="comment">     * 2.反转整个字符串</span></span><br><span class="line"><span class="comment">     * 3.反转各个单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseWords2() called with: s = [&quot; + s + &quot;]&quot;);</span></span><br><span class="line">        <span class="comment">// 1.去除首尾以及中间多余空格</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> removeSpace(s);</span><br><span class="line">        <span class="comment">// 2.反转整个字符串</span></span><br><span class="line">        reverseString(sb, <span class="number">0</span>, sb.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3.反转各个单词</span></span><br><span class="line">        reverseEachWord(sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringBuilder <span class="title function_">removeSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.removeSpace() called with: s = [&quot; + s + &quot;]&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) start++;</span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) end--;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(start);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="string">&#x27; &#x27;</span> || sb.charAt(sb.length() - <span class="number">1</span>) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sb.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.removeSpace returned: sb = [&quot; + sb + &quot;]&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反转字符串指定区间[start, end]的字符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(StringBuilder sb, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseString() called with: sb = [&quot; + sb + &quot;], start = [&quot; + start + &quot;], end = [&quot; + end + &quot;]&quot;);</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> sb.charAt(start);</span><br><span class="line">            sb.setCharAt(start, sb.charAt(end));</span><br><span class="line">            sb.setCharAt(end, temp);</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;ReverseWords.reverseString returned: sb = [&quot; + sb + &quot;]&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverseEachWord</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sb.length();</span><br><span class="line">        <span class="keyword">while</span> (start &lt; n) &#123;</span><br><span class="line">            <span class="keyword">while</span> (end &lt; n &amp;&amp; sb.charAt(end) != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverseString(sb, start, end - <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">            end = start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//解法三：双反转+移位，String 的 toCharArray() 方法底层会 new 一个和原字符串相同大小的 char 数组，空间复杂度：O(n)</span><br><span class="line">class Solution &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 思路：</span><br><span class="line">     *	①反转字符串  &quot;the sky is blue &quot; =&gt; &quot; eulb si yks eht&quot;</span><br><span class="line">     *	②遍历 &quot; eulb si yks eht&quot;，每次先对某个单词进行反转再移位</span><br><span class="line">     *	   这里以第一个单词进行为演示：&quot; eulb si yks eht&quot; ==反转=&gt; &quot; blue si yks eht&quot; ==移位=&gt; &quot;blue si yks eht&quot;</span><br><span class="line">     */</span><br><span class="line">    public String reverseWords(String s) &#123;</span><br><span class="line">        //步骤1：字符串整体反转（此时其中的单词也都反转了）</span><br><span class="line">        char[] initialArr = s.toCharArray();</span><br><span class="line">        reverse(initialArr, 0, s.length() - 1);</span><br><span class="line">        int k = 0;</span><br><span class="line">        for (int i = 0; i &lt; initialArr.length; i++) &#123;</span><br><span class="line">            if (initialArr[i] == &#x27; &#x27;) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            int tempCur = i;</span><br><span class="line">            while (i &lt; initialArr.length &amp;&amp; initialArr[i] != &#x27; &#x27;) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int j = tempCur; j &lt; i; j++) &#123;</span><br><span class="line">                if (j == tempCur) &#123; //步骤二：二次反转</span><br><span class="line">                    reverse(initialArr, tempCur, i - 1);//对指定范围字符串进行反转，不反转从后往前遍历一个个填充有问题</span><br><span class="line">                &#125;</span><br><span class="line">                //步骤三：移动操作</span><br><span class="line">                initialArr[k++] = initialArr[j];</span><br><span class="line">                if (j == i - 1) &#123; //遍历结束</span><br><span class="line">                    //避免越界情况，例如=&gt; &quot;asdasd df f&quot;，不加判断最后就会数组越界</span><br><span class="line">                    if (k &lt; initialArr.length) &#123;</span><br><span class="line">                        initialArr[k++] = &#x27; &#x27;;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (k == 0) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //参数三：以防出现如&quot;asdasd df f&quot;=&gt;&quot;f df asdasd&quot;正好凑满不需要省略空格情况</span><br><span class="line">            return new String(initialArr, 0, (k == initialArr.length) &amp;&amp; (initialArr[k - 1] != &#x27; &#x27;) ? k : k - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void reverse(char[] chars, int begin, int end) &#123;</span><br><span class="line">        for (int i = begin, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            chars[i] ^= chars[j];</span><br><span class="line">            chars[j] ^= chars[i];</span><br><span class="line">            chars[i] ^= chars[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-13"><a href="#python代码-13" class="headerlink" title="python代码"></a>python代码</h5><p>没啥用，没什么算法（）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseWords(self, s: str) -&gt; str:</span><br><span class="line">        # 删除前后空白</span><br><span class="line">        s = s.strip()</span><br><span class="line">        # 反转整个字符串</span><br><span class="line">        s = s[::-1]</span><br><span class="line">        # 将字符串拆分为单词，并反转每个单词</span><br><span class="line">        s = &#x27; &#x27;.join(word[::-1] for word in s.split())</span><br><span class="line">        return s</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    def <span class="title function_">reverseWords</span><span class="params">(self, s: str)</span> -&gt; str:</span><br><span class="line">        # 将字符串拆分为单词，即转换成列表类型</span><br><span class="line">        words = s.split()</span><br><span class="line"></span><br><span class="line">        # 反转单词</span><br><span class="line">        left, right = <span class="number">0</span>, len(words) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            words[left], words[right] = words[right], words[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        # 将列表转换成字符串</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(words)</span><br></pre></td></tr></table></figure>

<h3 id="4、28-找出字符串中第一个匹配项的下标-4-4"><a href="#4、28-找出字符串中第一个匹配项的下标-4-4" class="headerlink" title="4、28. 找出字符串中第一个匹配项的下标(4.4)"></a>4、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a>(4.4)</h3><p>已解答</p>
<p>简单</p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= haystack.length, needle.length &lt;= 104</code></li>
<li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li>
</ul>
<h4 id="思路-17"><a href="#思路-17" class="headerlink" title="思路"></a>思路</h4><p>学习KMP算法，掌握前缀表next即可，有减一和不减一两种实现方式，</p>
<p>定义两个指针i和j，<strong>j指向前缀起始位置，i指向后缀起始位置。</strong></p>
<p><strong>减一：</strong></p>
<p>​	<strong>计算最长相等前后缀，在构建next数组的时候，j</strong>&#x3D;-1，i&#x3D;1；这里是字符串needle，一个前指针，一个后指针去计算最长相等前后缀。所以应该判断相等的时候，应该j+1和i指向不是同一个的字符，如果不相等，就要根据前缀表next[j]，一直进行回退到next[j]（最长相等前后缀的位置）,直到字符相等并且j小于0，也就是-1；相等就把j++，说明前后缀相等了，需要加一，把j赋值给对应的前缀表next数组next[i]；接着i+1，进行下一个后缀进行匹配。</p>
<p>​	<strong>进行needle和haystack匹配的时候，</strong>j&#x3D;-1，i&#x3D;0；是为了匹配needle字符串和haystack字符串，所以应该判断相等的时候，应该j+1和i指向同一个要匹配的字符，如果不相等，就要根据前缀表next[j]，一直进行回退到next[j]（最长相等前后缀的位置）,直到字符相等并且j小于0，也就是-1；相等就把j++，说明前后缀相等了，需要加一，接着判断是否达到了needle数组的长度needle.length() - 1，然后返回最开始的位置i-needle.length() + 1；接着i+1，进行下一个后缀进行匹配。</p>
<h6 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h6><p>haystack aaabbb</p>
<p>needle aab</p>
<p>识别完成后，j&#x3D;2(needle.length() - 1)，i&#x3D;3，应该返回的位置是1 &#x3D; i - j;</p>
<p><strong>不减一：</strong></p>
<p>计算最长相等前后缀的next数组，整个判断的逻辑就是needle[i] &#x3D;&#x3D; needle[j],  不相等就是跳转是next[j-1]。</p>
<p>needle和haystack也是一样。</p>
<h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-14"><a href="#java代码-14" class="headerlink" title="java代码"></a>java代码</h5><h6 id="减一："><a href="#减一：" class="headerlink" title="减一："></a>减一：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 1.next数组减一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="comment">// 为needle创建next数组--前缀表</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next,needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="comment">// i是后缀串的末尾</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.length();i++)&#123;</span><br><span class="line">            <span class="comment">// 前缀和后缀不相同，需要按照next[j]进行不断回退</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; haystack.charAt(i)!=needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前缀和后缀相同</span></span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i)==needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">// 最长相等前缀串长度加一</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 达到长度返回结果</span></span><br><span class="line">            <span class="keyword">if</span>(j==needle.length()-<span class="number">1</span>)&#123; </span><br><span class="line">                System.out.println(i);</span><br><span class="line">                <span class="keyword">return</span> i-needle.length()+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组可以直接修改，不需要集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String needle)</span>&#123;</span><br><span class="line">        <span class="comment">// j记录最长相等前缀串 长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="comment">// i是后缀串的末尾</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;needle.length();i++)&#123;</span><br><span class="line">            <span class="comment">// 前缀和后缀不相同，需要按照next[j]进行不断回退</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; needle.charAt(i)!=needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前缀和后缀相同</span></span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i)==needle.charAt(j+<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">// 最长相等前缀串长度加一</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对next数组进行赋值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="不减一："><a href="#不减一：" class="headerlink" title="不减一："></a>不减一：</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.next数组不减一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="comment">// 为needle创建next数组--前缀表</span></span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">        getNext(next,needle);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="comment">// i是后缀串的末尾</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;haystack.length();i++)&#123;</span><br><span class="line">            <span class="comment">// 前缀和后缀不相同，需要按照next[j]进行不断回退</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack.charAt(i)!=needle.charAt(j))&#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前缀和后缀相同</span></span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">                <span class="comment">// 最长相等前缀串长度加一</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 达到长度返回结果</span></span><br><span class="line">            <span class="keyword">if</span>(j==needle.length())&#123;</span><br><span class="line">                <span class="keyword">return</span> i-j+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组可以直接修改，不需要集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span>[] next, String needle)</span>&#123;</span><br><span class="line">        <span class="comment">// j记录最长相等前缀串 长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        next[<span class="number">0</span>] = j;</span><br><span class="line">        <span class="comment">// i是后缀串的末尾</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;needle.length();i++)&#123;</span><br><span class="line">            <span class="comment">// 前缀和后缀不相同，需要按照next[j]进行不断回退</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; needle.charAt(i)!=needle.charAt(j))&#123;</span><br><span class="line">                j = next[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前缀和后缀相同</span></span><br><span class="line">            <span class="keyword">if</span>(needle.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">                <span class="comment">// 最长相等前缀串长度加一</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对next数组进行赋值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-14"><a href="#python代码-14" class="headerlink" title="python代码"></a>python代码</h5><h6 id="减一：-1"><a href="#减一：-1" class="headerlink" title="减一："></a>减一：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 1.减去1</span><br><span class="line">    def strStr(self, haystack: str, needle: str) -&gt; int:</span><br><span class="line">        def getNext(needle):</span><br><span class="line">            j = -1</span><br><span class="line">            next = [-1 for i in range(len(needle))]</span><br><span class="line">            for i in range(1,len(needle)):</span><br><span class="line">                # 前后缀不相等</span><br><span class="line">                while(j&gt;=0 and needle[i]!=needle[j+1] ):</span><br><span class="line">                    j = next[j]</span><br><span class="line">                # 前后缀相等</span><br><span class="line">                if needle[i]==needle[j+1]:</span><br><span class="line">                    j+=1</span><br><span class="line">                next[i] = j</span><br><span class="line">            return next</span><br><span class="line">        next = getNext(needle)</span><br><span class="line">        print(next)</span><br><span class="line">        j = -1</span><br><span class="line">        for i in range(len(haystack)):</span><br><span class="line">            while(j&gt;=0 and haystack[i]!=needle[j+1] ):</span><br><span class="line">                j = next[j]</span><br><span class="line">            if haystack[i]==needle[j+1]:</span><br><span class="line">                j+=1</span><br><span class="line">            if j == len(needle) - 1:</span><br><span class="line">                return i - j</span><br><span class="line">        return -1</span><br></pre></td></tr></table></figure>

<h6 id="不减一：-1"><a href="#不减一：-1" class="headerlink" title="不减一："></a>不减一：</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.不减去一</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">strStr</span>(<span class="params">self, haystack: <span class="built_in">str</span>, needle: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">needle</span>):</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="built_in">next</span> = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(needle))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(needle)):</span><br><span class="line">            <span class="comment"># 前后缀不相等</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> <span class="keyword">and</span> needle[i]!=needle[j] ):</span><br><span class="line">                j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 前后缀相等</span></span><br><span class="line">            <span class="keyword">if</span> needle[i]==needle[j]:</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">            <span class="built_in">next</span>[i] = j</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">next</span></span><br><span class="line">    <span class="built_in">next</span> = getNext(needle)</span><br><span class="line">    <span class="comment"># print(next)</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(haystack)):</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> <span class="keyword">and</span> haystack[i]!=needle[j] ):</span><br><span class="line">            j = <span class="built_in">next</span>[j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> haystack[i]==needle[j]:</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> j == <span class="built_in">len</span>(needle):</span><br><span class="line">            <span class="keyword">return</span> i - j +<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、LCR-122-路径加密-4-4"><a href="#5、LCR-122-路径加密-4-4" class="headerlink" title="5、LCR 122. 路径加密(4.4)"></a>5、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">LCR 122. 路径加密</a>(4.4)</h3><p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>假定一段路径记作字符串 <code>path</code>，其中以 “<code>.</code>“ 作为分隔符。现需将路径加密，加密方法为将 <code>path</code> 中的分隔符替换为空格 “<code> </code>“，请返回加密后的字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;a.aef.qerf.bb&quot;</span><br><span class="line"></span><br><span class="line">输出：&quot;a aef qerf bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>限制：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt;= path.length &lt;= 10000</span><br></pre></td></tr></table></figure>

<h4 id="思路-18"><a href="#思路-18" class="headerlink" title="思路"></a>思路</h4><p>双指针，向后填充，这样不会出现新的空间，并且只需要一次遍历即可。</p>
<p>replace也可以，但没有啥意义。。</p>
<h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><h5 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h5><p>双指针+向后填充</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 统计空格的个数</span></span><br><span class="line">    <span class="type">int</span> sOldSize = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">        	count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩充字符串s的⼤⼩，也就是每个空格替换成&quot;%20&quot;之后的⼤⼩</span></span><br><span class="line">    s.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + count * <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> sNewSize = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 从后先前将空格替换为&quot;%20&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[i - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            s[i - <span class="number">2</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            i -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="java代码-15"><a href="#java代码-15" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pathEncryption</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(path.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> path;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] p = path.toCharArray();</span><br><span class="line">        <span class="comment">//1.计数有多少点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;path.length();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path.charAt(i) == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.扩充数组 如有必要</span></span><br><span class="line">        <span class="type">char</span>[] arrNew = <span class="keyword">new</span> <span class="title class_">char</span>[p.length];</span><br><span class="line">		<span class="comment">//遍历 arr 数组，依次将arr的元素拷贝到 arrNew数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; p.length; i++) &#123;</span><br><span class="line">			arrNew[i] = p[i];</span><br><span class="line">		&#125;</span><br><span class="line">        System.out.println(p[p.length - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 3.替换赋值</span></span><br><span class="line">        <span class="comment">// for(int i = arrNew.length -1,int j=p.length-1; j &lt; i; i--,j--) &#123;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arrNew.length -<span class="number">1</span>,j=p.length-<span class="number">1</span>; i&gt;-<span class="number">1</span>; i--,j--) &#123;</span><br><span class="line">            <span class="comment">// System.out.println(p[j]);</span></span><br><span class="line">            <span class="keyword">if</span> (p[j] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                arrNew[i] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="comment">// 需要更多的替换字符的时候</span></span><br><span class="line">                <span class="comment">// arrNew[i-1] = &#x27;5&#x27;;</span></span><br><span class="line">                <span class="comment">// arrNew[i-2] = &#x27;6&#x27;;</span></span><br><span class="line">                <span class="comment">// i -= 2;</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                arrNew[i] = p[j];</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(arrNew);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、LCR-182-动态口令-4-4"><a href="#6、LCR-182-动态口令-4-4" class="headerlink" title="6、LCR 182. 动态口令(4.4)"></a>6、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">LCR 182. 动态口令</a>(4.4)</h3><p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>某公司门禁密码使用动态口令技术。初始密码为字符串 <code>password</code>，密码更新均遵循以下步骤：</p>
<ul>
<li>设定一个正整数目标值 <code>target</code></li>
<li>将 <code>password</code> 前 <code>target</code> 个字符按原顺序移动至字符串末尾</li>
</ul>
<p>请返回更新后的密码字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: password = &quot;s3cur1tyC0d3&quot;, target = 4</span><br><span class="line">输出: &quot;r1tyC0d3s3cu&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: password = &quot;lrloseumgh&quot;, target = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= target &lt; password.length &lt;= 10000</code></li>
</ul>
<h4 id="思路-19"><a href="#思路-19" class="headerlink" title="思路"></a>思路</h4><p>不申请额外空间</p>
<p>局部反转+整体反转 达到左旋转的目的。</p>
<h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-16"><a href="#java代码-16" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dynamicPassword</span><span class="params">(String password, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = password.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = target - <span class="number">1</span>;</span><br><span class="line">        swap(cs,left,right);</span><br><span class="line">        left = target;</span><br><span class="line">        right = cs.length- <span class="number">1</span>;</span><br><span class="line">        swap(cs,left,right);</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = cs.length- <span class="number">1</span>;</span><br><span class="line">        swap(cs,left,right);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(cs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span>[] cs,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> cs[left];</span><br><span class="line">            cs[left] = cs[right];</span><br><span class="line">            cs[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="python代码-15"><a href="#python代码-15" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dynamicPassword</span>(<span class="params">self, password: <span class="built_in">str</span>, target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">li,left,right</span>):</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right):</span><br><span class="line">                li[left],li[right] = li[right],li[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> li</span><br><span class="line">        li = [i <span class="keyword">for</span> i <span class="keyword">in</span> password]</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = target - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 第一次翻转前target个</span></span><br><span class="line">        li = reverse(li,left,right)</span><br><span class="line">        <span class="comment"># 第二次翻转从target+1到结束</span></span><br><span class="line">        left = target</span><br><span class="line">        right = <span class="built_in">len</span>(password) - <span class="number">1</span></span><br><span class="line">        li = reverse(li,left,right)</span><br><span class="line">        <span class="comment"># 第三次翻转所有</span></span><br><span class="line">        li = reverse(li,<span class="number">0</span>,right)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(li)</span><br></pre></td></tr></table></figure>

<h3 id="7、459-重复的子字符串-4-5"><a href="#7、459-重复的子字符串-4-5" class="headerlink" title="7、459. 重复的子字符串(4.5)"></a>7、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/repeated-substring-pattern/">459. 重复的子字符串</a>(4.5)</h3><p><a target="_blank" rel="noopener" href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html#%E6%80%9D%E8%B7%AF">卡尔思路</a></p>
<p>简单</p>
<p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abab&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;ab&quot; 重复两次构成。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;aba&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcabcabc&quot;</span><br><span class="line">输出: true</span><br><span class="line">解释: 可由子串 &quot;abc&quot; 重复四次构成。 (或子串 &quot;abcabc&quot; 重复两次构成。)</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
<h4 id="思路-20"><a href="#思路-20" class="headerlink" title="思路"></a>思路</h4><p>第一种—暴力解法</p>
<p>第一个for循环寻找子字符串，内部嵌套另一个进行拼接的字符串判断是否和目标字符串相等，相等就可以了。</p>
<p>第二种—-移动匹配</p>
<p>字符串s在   s+s中进行查找，如果仍然存在s，那么说明一定又重复子串构成，类似周期函数。</p>
<p>第三种KMP</p>
<p>s.length - 最长相等前后缀的长度 如果正好可以被s.length整除，就是最小子字符串。</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240405232101574.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240405232101574.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240405232101574"></p>
<h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-17"><a href="#java代码-17" class="headerlink" title="java代码"></a>java代码</h5><h6 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 原串加个空格(哨兵)，使下标从1开始，这样j从0开始，也不用初始化了</span></span><br><span class="line">        s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造 next 数组过程，j从0开始(空格)，i从2开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="comment">// 匹配不成功，j回到前一位置 next 数组所对应的值</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; chars[i] != chars[j + <span class="number">1</span>]) j = next[j];</span><br><span class="line">            <span class="comment">// 匹配成功，j往后移</span></span><br><span class="line">            <span class="keyword">if</span> (chars[i] == chars[j + <span class="number">1</span>]) j++;</span><br><span class="line">            <span class="comment">// 更新 next 数组的值</span></span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后判断是否是重复的子字符串，这里 next[len] 即代表next数组末尾的值</span></span><br><span class="line">        <span class="keyword">if</span> (next[len] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len]) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-16"><a href="#python代码-16" class="headerlink" title="python代码"></a>python代码</h5><p>kmp</p>
<h6 id="前缀表-减一"><a href="#前缀表-减一" class="headerlink" title="前缀表 减一"></a>前缀表 减一</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:  </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        nxt = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="variable language_">self</span>.getNext(nxt, s)</span><br><span class="line">        <span class="keyword">if</span> nxt[-<span class="number">1</span>] != -<span class="number">1</span> <span class="keyword">and</span> <span class="built_in">len</span>(s) % (<span class="built_in">len</span>(s) - (nxt[-<span class="number">1</span>] + <span class="number">1</span>)) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, nxt, s</span>):</span><br><span class="line">        nxt[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        j = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j+<span class="number">1</span>]:</span><br><span class="line">                j = nxt[j]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j+<span class="number">1</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            nxt[i] = j</span><br><span class="line">        <span class="keyword">return</span> nxt</span><br></pre></td></tr></table></figure>

<h6 id="前缀表-不减一"><a href="#前缀表-不减一" class="headerlink" title="前缀表 不减一"></a>前缀表 不减一</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:  </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        nxt = [<span class="number">0</span>] * <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="variable language_">self</span>.getNext(nxt, s)</span><br><span class="line">        <span class="keyword">if</span> nxt[-<span class="number">1</span>] != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(s) % (<span class="built_in">len</span>(s) - nxt[-<span class="number">1</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getNext</span>(<span class="params">self, nxt, s</span>):</span><br><span class="line">        nxt[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> s[i] != s[j]:</span><br><span class="line">                j = nxt[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            nxt[i] = j</span><br><span class="line">        <span class="keyword">return</span> nxt</span><br></pre></td></tr></table></figure>

<h6 id="使用-find"><a href="#使用-find" class="headerlink" title="使用 find"></a>使用 find</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        ss = s[<span class="number">1</span>:] + s[:-<span class="number">1</span>] </span><br><span class="line">        <span class="built_in">print</span>(ss.find(s))              </span><br><span class="line">        <span class="keyword">return</span> ss.find(s) != -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h6 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">repeatedSubstringPattern</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        substr = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n//<span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line">                substr = s[:i]</span><br><span class="line">                <span class="keyword">if</span> substr * (n//i) == s:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>





<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="1、232-用栈实现队列（4-5）"><a href="#1、232-用栈实现队列（4-5）" class="headerlink" title="1、232. 用栈实现队列（4.5）"></a>1、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a>（4.5）</h3><p>简单</p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>
</ul>
<h4 id="思路-21"><a href="#思路-21" class="headerlink" title="思路"></a>思路</h4><p>这就是模拟题目，不涉及算法</p>
<p>注意；可以看出peek()的实现，直接复用了pop()， 要不然，对stOut判空的逻辑又要重写一遍。</p>
<p>再多说一些代码开发上的习惯问题，在工业级别代码开发中，最忌讳的就是 实现一个类似的函数，直接把代码粘过来改一改就完事了。</p>
<p>这样的项目代码会越来越乱，<strong>一定要懂得复用，功能相近的函数要抽象出来，不要大量的复制粘贴，很容易出问题！（踩过坑的人自然懂）</strong></p>
<h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-18"><a href="#java代码-18" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 负责进栈</span></span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 负责出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;    </span><br><span class="line">        dumpstackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        dumpstackIn();</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dumpstackIn</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stackOut.isEmpty()) <span class="keyword">return</span>; </span><br><span class="line">        <span class="keyword">while</span> (!stackIn.isEmpty())&#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stackIn;</span><br><span class="line">    Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.初始化数据结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.进队操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.出队操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//可以直接使用peek返回的元素，因为peek函数</span></span><br><span class="line">        <span class="comment">// 已经保证stackOut队列不为空，所以直接出栈(出队)就可以</span></span><br><span class="line">        <span class="comment">// int peek = stackOut.peek();</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> peek();</span><br><span class="line">        stackOut.pop();</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.取得队列队首元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果stackOut不为空，直接返回他的栈顶就是队首的元素</span></span><br><span class="line">        <span class="keyword">if</span>(!stackOut.isEmpty()) <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">        <span class="comment">// 如果stackOut已经是空的，但是stackIn也是空的，说明有问题了，</span></span><br><span class="line">        <span class="comment">// 没有队首元素</span></span><br><span class="line">        <span class="keyword">if</span>(stackIn.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果stackOut为空，stackIn不为空，说明现在需要把</span></span><br><span class="line">        <span class="comment">// stackIn的元素入栈加入stackOut之中</span></span><br><span class="line">        <span class="keyword">while</span>(!stackIn.isEmpty())&#123;</span><br><span class="line">            stackOut.push(stackIn.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 都不为空队列才不为空</span></span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h5 id="python代码-17"><a href="#python代码-17" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        in主要负责push，out主要负责pop</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack_in = []</span><br><span class="line">        <span class="variable language_">self</span>.stack_out = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        有新元素进来，就往in里面push</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stack_in.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stack_out:</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.stack_in)):</span><br><span class="line">                <span class="variable language_">self</span>.stack_out.append(<span class="variable language_">self</span>.stack_in.pop())</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stack_out.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        ans = <span class="variable language_">self</span>.pop()</span><br><span class="line">        <span class="variable language_">self</span>.stack_out.append(ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        只要in或者out有元素，说明队列不为空</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> (<span class="variable language_">self</span>.stack_in <span class="keyword">or</span> <span class="variable language_">self</span>.stack_out)</span><br></pre></td></tr></table></figure>

<p>重写代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stackIn = []</span><br><span class="line">        <span class="variable language_">self</span>.stackOut = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.stackIn.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># stackOut不为空直接返回即可</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.stackOut : </span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.stackOut.pop()</span><br><span class="line">        <span class="comment"># 如果stackOut为空，stackIn也是空的，说明操作空栈了</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.stackIn:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果stackOut为空，stackIn不是空的，</span></span><br><span class="line">        <span class="comment"># 将stackIn的元素入栈stackOut即可</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">self</span>.stackIn):</span><br><span class="line">            <span class="variable language_">self</span>.stackOut.append(<span class="variable language_">self</span>.stackIn.pop())</span><br><span class="line">        <span class="comment"># 加入之后，stack一定不为空，所以直接弹出即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.stackOut.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        peek = <span class="variable language_">self</span>.pop()</span><br><span class="line">        <span class="comment"># 在stackOut删掉之后，再加进去即可</span></span><br><span class="line">        <span class="variable language_">self</span>.stackOut.append(peek)</span><br><span class="line">        <span class="keyword">return</span> peek</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.stackIn <span class="keyword">and</span> <span class="keyword">not</span> <span class="variable language_">self</span>.stackOut</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>



<h3 id="2、225-用队列实现栈（4-5）"><a href="#2、225-用队列实现栈（4-5）" class="headerlink" title="2、225. 用队列实现栈（4.5）"></a>2、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a>（4.5）</h3><p>简单</p>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>
<p>实现 <code>MyStack</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>
<li><code>int pop()</code> 移除并返回栈顶元素。</li>
<li><code>int top()</code> 返回栈顶元素。</li>
<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 2, 2, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyStack myStack = new MyStack();</span><br><span class="line">myStack.push(1);</span><br><span class="line">myStack.push(2);</span><br><span class="line">myStack.top(); // 返回 2</span><br><span class="line">myStack.pop(); // 返回 2</span><br><span class="line">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li>
<li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li>
</ul>
<p><strong>进阶：</strong>你能否仅用一个队列来实现栈</p>
<h4 id="思路-22"><a href="#思路-22" class="headerlink" title="思路"></a>思路</h4><p>使用一个队列实现。</p>
<p>出栈用队列模拟，就是把队首的元素直到最后一个，先弹出队列再加入队列，直到最后一个，弹出即可。</p>
<p>top，就是弹出去之后，再加回来。</p>
<h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-19"><a href="#java代码-19" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        queue.add(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rePosition</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        rePosition();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">peek</span> <span class="operator">=</span> pop();</span><br><span class="line">        push(peek);</span><br><span class="line">        <span class="keyword">return</span> peek;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// queue.isEmpty()</span></span><br><span class="line">        <span class="keyword">return</span> queue.size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rePosition</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="comment">//将队尾（栈顶）元素之前的所有元素，先出队列，再入队列</span></span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// queue.poll(),remove()删除并返回第一个元素。</span></span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



<h5 id="python代码-18"><a href="#python代码-18" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.que = deque()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="variable language_">self</span>.que.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.que)-<span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.que.append(<span class="variable language_">self</span>.que.popleft())</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.que.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 写法一：</span></span><br><span class="line">        <span class="comment"># if self.empty():</span></span><br><span class="line">        <span class="comment">#     return None</span></span><br><span class="line">        <span class="comment"># return self.que[-1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 写法二：</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.que)-<span class="number">1</span>):</span><br><span class="line">            <span class="variable language_">self</span>.que.append(<span class="variable language_">self</span>.que.popleft())</span><br><span class="line">        temp = <span class="variable language_">self</span>.que.popleft()</span><br><span class="line">        <span class="variable language_">self</span>.que.append(temp)</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> <span class="variable language_">self</span>.que</span><br></pre></td></tr></table></figure>

<p>重写代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class MyStack:</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">         # 创建一个双端队列,但是当正常队列去使用</span><br><span class="line">        self.queue = deque()</span><br><span class="line"></span><br><span class="line">    def push(self, x: int) -&gt; None:</span><br><span class="line">        self.queue.append(x)</span><br><span class="line"></span><br><span class="line">    def pop(self) -&gt; int:</span><br><span class="line">        length = len(self.queue)</span><br><span class="line">        length -=1</span><br><span class="line">        while(length &gt; 0):</span><br><span class="line">            self.push(self.queue.popleft())</span><br><span class="line">            length -=1</span><br><span class="line">        return self.queue.popleft()</span><br><span class="line"></span><br><span class="line">    def top(self) -&gt; int:</span><br><span class="line">        peek = self.pop()</span><br><span class="line">        self.push(peek)</span><br><span class="line">        return peek</span><br><span class="line"></span><br><span class="line">    def empty(self) -&gt; bool:</span><br><span class="line">        return len(self.queue) == 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Your MyStack object will be instantiated and called as such:</span><br><span class="line"># obj = MyStack()</span><br><span class="line"># obj.push(x)</span><br><span class="line"># param_2 = obj.pop()</span><br><span class="line"># param_3 = obj.top()</span><br><span class="line"># param_4 = obj.empty()</span><br></pre></td></tr></table></figure>



<h3 id="3、20-有效的括号-4-6"><a href="#3、20-有效的括号-4-6" class="headerlink" title="3、20. 有效的括号(4.6)"></a>3、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a>(4.6)</h3><p>简单</p>
<p>提示</p>
<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<h4 id="思路-23"><a href="#思路-23" class="headerlink" title="思路"></a>思路</h4><p>使用栈的思路，进行匹配，但是进栈，使用遇到左括号，进栈右括号，这样方便后续判断是否配对即可</p>
<p>先来分析一下 这里有三种不匹配的情况，</p>
<ol>
<li>第一种情况，字符串里左方向的括号多余了 ，所以不匹配。 <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020080915505387.png" class="lazyload" data-srcset="https://code-thinking-1253855093.file.myqcloud.com/pics/2020080915505387.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="括号匹配1"></li>
<li>第二种情况，括号没有多余，但是 括号的类型没有匹配上。 <img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/20200809155107397.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/20200809155107397.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="括号匹配2"></li>
<li>第三种情况，字符串里右方向的括号多余了，所以不匹配。 <img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200809155115779.png" class="lazyload" data-srcset="https://code-thinking-1253855093.file.myqcloud.com/pics/20200809155115779.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="括号匹配3"></li>
</ol>
<h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-20"><a href="#java代码-20" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span> ch;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            ch = s.charAt(i);</span><br><span class="line">            <span class="comment">//碰到左括号，就把相应的右括号入栈</span></span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                deque.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deque.isEmpty() || deque.peek() != ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果是右括号判断是否和栈顶元素匹配</span></span><br><span class="line">                deque.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后判断栈中元素是否匹配</span></span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-19"><a href="#python代码-19" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def isValid(self, s: str) -&gt; bool:</span><br><span class="line">        stack = []</span><br><span class="line">        </span><br><span class="line">        for item in s:</span><br><span class="line">            if item == &#x27;(&#x27;:</span><br><span class="line">                stack.append(&#x27;)&#x27;)</span><br><span class="line">            elif item == &#x27;[&#x27;:</span><br><span class="line">                stack.append(&#x27;]&#x27;)</span><br><span class="line">            elif item == &#x27;&#123;&#x27;:</span><br><span class="line">                stack.append(&#x27;&#125;&#x27;)</span><br><span class="line">            elif not stack or stack[-1] != item:</span><br><span class="line">                return False</span><br><span class="line">            else:</span><br><span class="line">                stack.pop()</span><br><span class="line">        </span><br><span class="line">        return True if not stack else False</span><br></pre></td></tr></table></figure>

<h3 id="4、1047-删除字符串中的所有相邻重复项-4-7"><a href="#4、1047-删除字符串中的所有相邻重复项-4-7" class="headerlink" title="4、1047. 删除字符串中的所有相邻重复项(4.7)"></a>4、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a>(4.7)</h3><p>简单</p>
<p>提示</p>
<p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= S.length &lt;= 20000</code></li>
<li><code>S</code> 仅由小写英文字母组成。</li>
</ol>
<h4 id="思路-24"><a href="#思路-24" class="headerlink" title="思路"></a>思路</h4><p>使用栈去处理相同元素。</p>
<h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-21"><a href="#java代码-21" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty() &amp;&amp; stack.peek() == ch) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">build</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            build.insert(<span class="number">0</span>, stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String removeDuplicates(String s) &#123;</span><br><span class="line">        // if(s.equals(&quot;&quot;)) </span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        char[] cs = s.toCharArray();</span><br><span class="line">        for(int i=0;i&lt;cs.length;i++)&#123;</span><br><span class="line">            if(stack.isEmpty()||cs[i] != stack.peek())&#123;</span><br><span class="line">                stack.push(cs[i]);</span><br><span class="line">            &#125;else if(cs[i] == stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            sb.append(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String result = sb.reverse().toString();</span><br><span class="line">        // System.out.println(result);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-20"><a href="#python代码-20" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def removeDuplicates(self, s: str) -&gt; str:</span><br><span class="line">         stk = list()</span><br><span class="line">        for ch in s:</span><br><span class="line">            if stk and stk[-1] == ch:</span><br><span class="line">                stk.pop()</span><br><span class="line">            else:</span><br><span class="line">                stk.append(ch)</span><br><span class="line">        return &quot;&quot;.join(stk)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5、150-逆波兰表达式求值-4-8"><a href="#5、150-逆波兰表达式求值-4-8" class="headerlink" title="5、150. 逆波兰表达式求值(4.8)"></a>5、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a>(4.8)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437">逆波兰表示法</a> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;*&#39;</code> 和 <code>&#39;/&#39;</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 104</code></li>
<li><code>tokens[i]</code> 是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），或是在范围 <code>[-200, 200]</code> 内的一个整数</li>
</ul>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中</li>
</ul>
<h4 id="思路-25"><a href="#思路-25" class="headerlink" title="思路"></a>思路</h4><p>和处理相邻重复项类似，遇到+,-,*,&#x2F;时，只需要弹出栈顶和次栈顶进行操作，遇到数字直接输入栈中即可，相对容易。</p>
<h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-22"><a href="#java代码-22" class="headerlink" title="java代码"></a>java代码</h5><h6 id="使用LinkedList实现栈"><a href="#使用LinkedList实现栈" class="headerlink" title="使用LinkedList实现栈"></a>使用LinkedList实现栈</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        // 必须用LinkedList&lt;Integer&gt;才能使用removeLast()</span><br><span class="line">        LinkedList&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        // Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        // 数组是length,字符串是length()</span><br><span class="line">        for(int i=0;i&lt;tokens.length;i++)&#123;</span><br><span class="line">            if(tokens[i].equals(&quot;+&quot;))&#123;</span><br><span class="line">                queue.add(queue.removeLast()+queue.removeLast());</span><br><span class="line">            &#125;else if(tokens[i].equals(&quot;-&quot;))&#123;</span><br><span class="line">                queue.add((-1)*queue.removeLast()+queue.removeLast());</span><br><span class="line">            &#125;else if(tokens[i].equals(&quot;*&quot;))&#123;</span><br><span class="line">                queue.add(queue.removeLast()*queue.removeLast());</span><br><span class="line">            &#125;else if(tokens[i].equals(&quot;/&quot;))&#123;</span><br><span class="line">                int b = queue.removeLast();</span><br><span class="line">                int a = queue.removeLast();</span><br><span class="line">                queue.add((int)(a/b));</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                queue.add(Integer.parseInt(tokens[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return queue.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用LinkedList实现栈的另一种方式"><a href="#使用LinkedList实现栈的另一种方式" class="headerlink" title="使用LinkedList实现栈的另一种方式"></a>使用LinkedList实现栈的另一种方式</h6><p>push相当于addFirst方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int evalRPN(String[] tokens) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = new LinkedList();</span><br><span class="line">        for (String s : tokens) &#123;</span><br><span class="line">            if (&quot;+&quot;.equals(s)) &#123;        // leetcode 内置jdk的问题，不能使用==判断字符串是否相等</span><br><span class="line">                stack.push(stack.pop() + stack.pop());      // 注意 - 和/ 需要特殊处理</span><br><span class="line">            &#125; else if (&quot;-&quot;.equals(s)) &#123;</span><br><span class="line">                stack.push(-stack.pop() + stack.pop());</span><br><span class="line">            &#125; else if (&quot;*&quot;.equals(s)) &#123;</span><br><span class="line">                stack.push(stack.pop() * stack.pop());</span><br><span class="line">            &#125; else if (&quot;/&quot;.equals(s)) &#123;</span><br><span class="line">                int temp1 = stack.pop();</span><br><span class="line">                int temp2 = stack.pop();</span><br><span class="line">                stack.push(temp2 / temp1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stack.push(Integer.valueOf(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="python代码-21"><a href="#python代码-21" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def evalRPN(self, tokens: List[str]) -&gt; int:</span><br><span class="line">        li = []</span><br><span class="line">        for i in tokens:</span><br><span class="line">            if i == &#x27;+&#x27;:</span><br><span class="line">                b = li.pop()</span><br><span class="line">                a = li.pop()</span><br><span class="line">                li.append(a+b)</span><br><span class="line">            elif i == &#x27;-&#x27;:</span><br><span class="line">                b = li.pop()</span><br><span class="line">                a = li.pop()</span><br><span class="line">                li.append(a-b)</span><br><span class="line">            elif i == &#x27;*&#x27;:</span><br><span class="line">                b = li.pop()</span><br><span class="line">                a = li.pop()</span><br><span class="line">                li.append(a*b)</span><br><span class="line">            elif i == &#x27;/&#x27;:</span><br><span class="line">                b = li.pop()</span><br><span class="line">                a = li.pop()</span><br><span class="line">                li.append(int(a/b))</span><br><span class="line">            else:</span><br><span class="line">                li.append(int(i))</span><br><span class="line">            # print(li)</span><br><span class="line">        return li[0]</span><br></pre></td></tr></table></figure>

<p>优化代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from operator import add, sub, mul</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    op_map = &#123;&#x27;+&#x27;: add, &#x27;-&#x27;: sub, &#x27;*&#x27;: mul, &#x27;/&#x27;: lambda x, y: int(x / y)&#125;</span><br><span class="line">    </span><br><span class="line">    def evalRPN(self, tokens: List[str]) -&gt; int:</span><br><span class="line">        stack = []</span><br><span class="line">        for token in tokens:</span><br><span class="line">            if token not in &#123;&#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;&#125;:</span><br><span class="line">                stack.append(int(token))</span><br><span class="line">            else:</span><br><span class="line">                op2 = stack.pop()</span><br><span class="line">                op1 = stack.pop()</span><br><span class="line">                stack.append(self.op_map[token](op1, op2))  # 第一个出来的在运算符后面</span><br><span class="line">        return stack.pop()</span><br></pre></td></tr></table></figure>

<h3 id="6、239-滑动窗口最大值-4-9"><a href="#6、239-滑动窗口最大值-4-9" class="headerlink" title="6、239. 滑动窗口最大值(4.9)"></a>6、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a>(4.9)</h3><p>困难</p>
<p>相关标签</p>
<p>相关企业</p>
<p>提示</p>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
<h4 id="思路-26"><a href="#思路-26" class="headerlink" title="思路"></a>思路</h4><p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列</strong></p>
<p><strong>不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。</strong></p>
<p><strong>实现单调队列（难）</strong></p>
<p>弹出元素pop</p>
<p>弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出<br>同时判断队列当前是否为空。</p>
<p>加入元素push</p>
<p>如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止；</p>
<p>比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2</p>
<p><strong>解释</strong>：当一个要被push进来的value时，说明此时这个值已经进入了这个滑动窗口中，他比之前队列的某些值大，那他就是最近的滑动窗口有可能的最大值，就不需要再维护前面的单调队列中小于他的元素，因此可以直接进行pop掉。</p>
<p>对于pop来说，如果队列不为空，当这个值等于单调队列的队首时，进行弹出即可；如果不等于，不用进行操作，因为在push中，压根没有进入这个队列</p>
<h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-23"><a href="#java代码-23" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//自定义数组</span><br><span class="line">class MyQueue &#123;</span><br><span class="line">    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line">    //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出</span><br><span class="line">    //同时判断队列当前是否为空</span><br><span class="line">    void poll(int val) &#123;</span><br><span class="line">        if (!deque.isEmpty() &amp;&amp; val == deque.peek()) &#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出</span><br><span class="line">    //保证队列元素单调递减</span><br><span class="line">    //比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2</span><br><span class="line">    void add(int val) &#123;</span><br><span class="line">        while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) &#123;</span><br><span class="line">            deque.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        deque.add(val);</span><br><span class="line">    &#125;</span><br><span class="line">    //队列队顶元素始终为最大值</span><br><span class="line">    int peek() &#123;</span><br><span class="line">        return deque.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] maxSlidingWindow(int[] nums, int k) &#123;</span><br><span class="line">        if (nums.length == 1) &#123;</span><br><span class="line">            return nums;</span><br><span class="line">        &#125;</span><br><span class="line">        int len = nums.length - k + 1;</span><br><span class="line">        //存放结果元素的数组</span><br><span class="line">        int[] res = new int[len];</span><br><span class="line">        int num = 0;</span><br><span class="line">        //自定义队列</span><br><span class="line">        MyQueue myQueue = new MyQueue();</span><br><span class="line">        //先将前k的元素放入队列</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123;</span><br><span class="line">            myQueue.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res[num++] = myQueue.peek();</span><br><span class="line">        for (int i = k; i &lt; nums.length; i++) &#123;</span><br><span class="line">            //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列</span><br><span class="line">            myQueue.poll(nums[i - k]);</span><br><span class="line">            //滑动窗口加入最后面的元素</span><br><span class="line">            myQueue.add(nums[i]);</span><br><span class="line">            //记录对应的最大值</span><br><span class="line">            res[num++] = myQueue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-22"><a href="#python代码-22" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>: <span class="comment">#单调队列（从大到小</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.queue = deque() <span class="comment">#这里需要使用deque实现单调队列，直接使用list会超时</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。</span></span><br><span class="line">    <span class="comment">#同时pop之前判断队列当前是否为空。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.queue <span class="keyword">and</span> value == <span class="variable language_">self</span>.queue[<span class="number">0</span>]:</span><br><span class="line">            <span class="variable language_">self</span>.queue.popleft()<span class="comment">#list.pop()时间复杂度为O(n),这里需要使用collections.deque()</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">#如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">#这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="variable language_">self</span>.queue <span class="keyword">and</span> value &gt; <span class="variable language_">self</span>.queue[-<span class="number">1</span>]:</span><br><span class="line">            <span class="variable language_">self</span>.queue.pop()</span><br><span class="line">        <span class="variable language_">self</span>.queue.append(value)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#查询当前队列里的最大值 直接返回队列前端也就是front就可以了。</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">front</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.queue[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        que = MyQueue()</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k): <span class="comment">#先将前k的元素放进队列</span></span><br><span class="line">            que.push(nums[i])</span><br><span class="line">        result.append(que.front()) <span class="comment">#result 记录前k的元素的最大值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, <span class="built_in">len</span>(nums)):</span><br><span class="line">            que.pop(nums[i - k]) <span class="comment">#滑动窗口移除最前面元素</span></span><br><span class="line">            que.push(nums[i]) <span class="comment">#滑动窗口前加入最后面的元素</span></span><br><span class="line">            result.append(que.front()) <span class="comment">#记录对应的最大值</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="7、347-前-K-个高频元素-4-10"><a href="#7、347-前-K-个高频元素-4-10" class="headerlink" title="7、347. 前 K 个高频元素(4.10)"></a>7、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a>(4.10)</h3><p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li>
<li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li>
</ul>
<p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p>
<h4 id="思路-27"><a href="#思路-27" class="headerlink" title="思路"></a>思路</h4><p>对这种频率问题，想法就是哈希表，使用map进行保存k,v，然后对所有的map集合进行按照value排序，返回前k个即可。</p>
<p>优化思路</p>
<p>不需要对所有的进行排序，使用优先级队列(底层是堆，分为大顶堆和小顶堆)，只维护k个元素，如果采用大顶堆，每次pop就会弹出最大的那个，会导致得到的不是频率前k个 的，如果是小顶堆，每次弹出的是最小的元素，到最后就会得到频率前k个的元素。</p>
<h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-24"><a href="#java代码-24" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*Comparator接口说明:</span><br><span class="line"> * 返回负数，形参中第一个参数排在前面；返回正数，形参中第二个参数排在前面</span><br><span class="line"> * 对于队列：排在前面意味着往队头靠</span><br><span class="line"> * 对于堆（使用PriorityQueue实现）：从队头到队尾按从小到大排就是最小堆（小顶堆），</span><br><span class="line"> * 从队头到队尾按从大到小排就是最大堆（大顶堆）---&gt;队头元素相当于堆的根节点</span><br><span class="line"> * */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    //解法1：基于大顶堆实现</span><br><span class="line">    public int[] topKFrequent1(int[] nums, int k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key为数组元素值,val为对应出现次数</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num,0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        //在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数</span><br><span class="line">        //出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)</span><br><span class="line">        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair2[1] - pair1[1]);</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;//大顶堆需要对所有元素进行排序</span><br><span class="line">            pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ans = new int[k];</span><br><span class="line">        for (int i = 0; i &lt; k; i++) &#123; //依次从队头弹出k个,就是出现频率前k高的元素</span><br><span class="line">            ans[i] = pq.poll()[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">    //解法2：基于小顶堆实现</span><br><span class="line">    public int[] topKFrequent2(int[] nums, int k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key为数组元素值,val为对应出现次数</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        //在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数</span><br><span class="line">        //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span><br><span class="line">        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair1[1] - pair2[1]);</span><br><span class="line">        for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; //小顶堆只需要维持k个元素有序</span><br><span class="line">            if (pq.size() &lt; k) &#123; //小顶堆元素个数小于k个时直接加</span><br><span class="line">                pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (entry.getValue() &gt; pq.peek()[1]) &#123; //当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span><br><span class="line">                    pq.poll(); //弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span><br><span class="line">                    pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] ans = new int[k];</span><br><span class="line">        for (int i = k - 1; i &gt;= 0; i--) &#123; //依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span><br><span class="line">            ans[i] = pq.poll()[0];</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-23"><a href="#python代码-23" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#时间复杂度：O(nlogk)</span><br><span class="line">#空间复杂度：O(n)</span><br><span class="line">import heapq</span><br><span class="line">class Solution:</span><br><span class="line">    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:</span><br><span class="line">        #要统计元素出现频率</span><br><span class="line">        map_ = &#123;&#125; #nums[i]:对应出现的次数</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            map_[nums[i]] = map_.get(nums[i], 0) + 1</span><br><span class="line">        </span><br><span class="line">        #对频率排序</span><br><span class="line">        #定义一个小顶堆，大小为k</span><br><span class="line">        pri_que = [] #小顶堆</span><br><span class="line">        </span><br><span class="line">        #用固定大小为k的小顶堆，扫描所有频率的数值</span><br><span class="line">        for key, freq in map_.items():</span><br><span class="line">            heapq.heappush(pri_que, (freq, key))</span><br><span class="line">            if len(pri_que) &gt; k: #如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span><br><span class="line">                heapq.heappop(pri_que)</span><br><span class="line">        </span><br><span class="line">        #找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span><br><span class="line">        result = [0] * k</span><br><span class="line">        for i in range(k-1, -1, -1):</span><br><span class="line">            result[i] = heapq.heappop(pri_que)[1]</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240411003215936.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240411003215936.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240411003215936"></p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="0、二叉树基础"><a href="#0、二叉树基础" class="headerlink" title="0、二叉树基础"></a>0、二叉树基础</h3><h4 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h4><p>在我们解题过程中二叉树有两种主要的形式:满二叉树和完全二叉树。</p>
<h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>满二叉树:如果一棵二叉树只有度为O的结点和度为2的结点，并且度为O的结点在同一层上，则这棵二叉树为满二叉树。</p>
<p>如图所示:</p>
<img src="C:/Users/ZJJ/AppData/Roaming/Typora/typora-user-images/image-20240412112150873.png" class="lazyload" data-srcset="C:/Users/ZJJ/AppData/Roaming/Typora/typora-user-images/image-20240412112150873.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240412112150873" style="zoom:33%;" />

<p>这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。|</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>完全二叉树的定义如下︰</p>
<p>在完全二叉树中，除了<strong>最底层节点可能没填满外，其余每层节点数都达到最大值</strong>，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第h层（h从1开始)，则该层包含1~2^(h-1)个节点。</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412112251729.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412112251729.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240412112251729">之前我们刚刚讲过优先级队列其实是⼀个堆，堆就是⼀棵完全⼆叉树，同时保证⽗⼦节点的顺序关系</p>
<h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p>前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值;</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;</li>
<li>它的左、右子树也分别为二叉排序树</li>
</ul>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412112749283.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412112749283.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240412112749283"></p>
<p>中序遍历后，是一个有序数组。</p>
<h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>平衡二叉搜索树︰又被称为AVL(Adelson-velsky and Landis)树，且具有以下性质︰</p>
<p><strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong><br>如图:</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412112928709.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412112928709.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240412112928709"></p>
<p>最后一棵不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。<br>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set,unordered_map、unordered_set底层实现是哈希表。<br>所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚!</p>
<h4 id="二叉树的存储方式"><a href="#二叉树的存储方式" class="headerlink" title="二叉树的存储方式"></a>二叉树的存储方式</h4><p>二叉树可以链式存储，也可以顺序存储。<br>那么<strong>链式存储方式就用指针，顺序存储的方式就是用数组</strong>。<br>顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。</p>
<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412113456963.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412113456963.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240412113456963" style="zoom: 50%;" />

<p>​	链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢?其实就是用数组来存储二叉树，顺序存储的方式如图:</p>
<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412113525209.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240412113525209.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240412113525209" style="zoom:50%;" />

<p>用数组来存储二叉树如何遍历的呢?<br><strong>如果父节点的数组下标是 i，那么它的左孩子就是i*2+1，右孩子就是i*2+2。</strong>但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。</p>
<p>所以大家要了解，用数组依然可以表示二叉树。|</p>
<h4 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h4><p>关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。<br>一些同学用做了很多二叉树的题目了，可能知道前中后序遍历，可能知道层序遍历，但是却没有框架。<br>我这里把二叉树的几种遍历方式列出来，大家就可以——串起来了。<br><strong>二叉树主要有两种遍历方式</strong>︰<br>1.<strong>深度优先遍历</strong>︰先往深走，遇到叶子节点再往回走。</p>
<p>2.<strong>广度优先遍历</strong>:一层一层的去遍历。<br>这两种遍历是图论中最基本的两种遍历方式，后面在介绍图论的时候还会介绍到。那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式:</p>
<p>这两种遍历是图论中最基本的两种遍历方式，后面在介绍图论的时候还会介绍到。那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式:</p>
<ul>
<li>深度优先遍历<ul>
<li>前序遍历(递归法，迭代法)</li>
<li>中序遍历(递归法，迭代法)</li>
<li>后序遍历(递归法，迭代法)</li>
</ul>
</li>
<li>广度优先遍历<ul>
<li>层次遍历(迭代法)</li>
</ul>
</li>
</ul>
<p>​	在深度优先遍历中:有三个顺序，前中后序遍历，有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。<br>​	<strong>这里前中后，其实指的就是中间节点的遍历顺序，</strong>只要大家记住前中后序指的就是中间节点的位置就可以了。看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式</p>
<ul>
<li>前序遍历:中左右</li>
<li>中序遍历:左中右</li>
<li>后序遍历:左右中</li>
</ul>
<p>大家可以对着如下图，看看自己理解的前后中序有没有问题。</p>
<p>最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。</p>
<p>之前我们讲栈与队列的时候，<strong>就说过栈其实就是递归的一种实现结构</strong>，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。</p>
<p>而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p>
<p>这里其实我们又了解了栈与队列的一个应用场景了。<br>具体的实现我们后面都会讲的，这里大家先要清楚这些理论基础。</p>
<h4 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h4><p>刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。</p>
<p>C++代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>大家会发现二叉树的定义和链表是差不多的，相对于链表，二叉树的节点里多了一个指针，有两个指针，指向左右孩子。</p>
<p>这里要提醒大家要注意二叉树节点定义的书写方式。</p>
<p>在现场面试的时候面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼!</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>二叉树是一种基础数据结构，在算法面试中都是常客，也是众多数据结构的基石。<br>本篇我们介绍了二叉树的种类、存储方式、遍历方式以及定义，比较全面的介绍了二叉树各个方面的重点，帮助大家扫一遍基础。<br>说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。</p>
<h3 id="1、二叉树前中后序递归遍历-4-11"><a href="#1、二叉树前中后序递归遍历-4-11" class="headerlink" title="1、二叉树前中后序递归遍历(4.11)"></a>1、二叉树前中后序递归遍历(4.11)</h3><p><strong>思考方式：</strong></p>
<p>1、确定递归函数的参数和返回值。</p>
<p>2、确定终止条件</p>
<p>3、确定单层递归的逻辑</p>
<h4 id="1-144-二叉树的前序遍历-4-11"><a href="#1-144-二叉树的前序遍历-4-11" class="headerlink" title="(1)144. 二叉树的前序遍历(4.11)"></a>(1)<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>(4.11)</h4><p>简单</p>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>
<p><strong>示例 1：</strong></p>
<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/inorder_1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/inorder_1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>
<h5 id="思路-28"><a href="#思路-28" class="headerlink" title="思路"></a>思路</h5><p>先中，再左再右部分，进行遍历。</p>
<h5 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h5><p>java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        preOrder(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode node,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//前序</span></span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        result.add(node.val);</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        preOrder(node.left,result);</span><br><span class="line">        <span class="comment">// 右</span></span><br><span class="line">        preOrder(node.right,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preOrder</span>(<span class="params">root,li</span>):</span><br><span class="line">            // 终止条件，节点是<span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            // 将中节点val插入li</span><br><span class="line">            li.append(root.val)</span><br><span class="line">            //进入左子树</span><br><span class="line">            preOrder(root.left,li)</span><br><span class="line">            //进入右子树</span><br><span class="line">            preOrder(root.right,li)</span><br><span class="line">        li = []</span><br><span class="line">        preOrder(root,li)</span><br><span class="line">        <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure>

<h4 id="2-94-二叉树的中序遍历-4-11"><a href="#2-94-二叉树的中序遍历-4-11" class="headerlink" title="(2)94. 二叉树的中序遍历(4.11)"></a>(2)<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>(4.11)</h4><p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p>
<p><strong>示例 1：</strong></p>
<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
<h5 id="思路-29"><a href="#思路-29" class="headerlink" title="思路"></a>思路</h5><p>先左，再中再右部分，进行遍历。</p>
<h5 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h5><p>java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inorder(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root,List&lt;Integer&gt; res )</span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件，root是null的时候</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//进入左子树</span></span><br><span class="line">        inorder(root.left,res);</span><br><span class="line">        <span class="comment">// 处理中节点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">//进入右子树</span></span><br><span class="line">        inorder(root.right,res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root,li</span>):</span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>: <span class="keyword">return</span></span><br><span class="line">            <span class="comment">#进入左子树</span></span><br><span class="line">            inorder(root.left,li)</span><br><span class="line">            <span class="comment">#处理中节点</span></span><br><span class="line">            li.append(root.val)</span><br><span class="line">            <span class="comment">#进入右子树</span></span><br><span class="line">            inorder(root.right,li)</span><br><span class="line">        li = []</span><br><span class="line">        inorder(root,li)</span><br><span class="line">        <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure>

<h4 id="3-145-二叉树的后序遍历-4-11"><a href="#3-145-二叉树的后序遍历-4-11" class="headerlink" title="(3)145. 二叉树的后序遍历(4.11)"></a>(3)<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a>(4.11)</h4><p>简单</p>
<p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/pre1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/pre1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>
<h5 id="思路-30"><a href="#思路-30" class="headerlink" title="思路"></a>思路</h5><p>先左，再右，最后是根节点</p>
<h5 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h5><p>java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        postorder(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root,List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//进入左子树</span></span><br><span class="line">        postorder(root.left,res);</span><br><span class="line">        <span class="comment">//进入右子树</span></span><br><span class="line">        postorder(root.right,res);</span><br><span class="line">        <span class="comment">//处理根节点</span></span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">postorder</span>(<span class="params">root,li</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root : <span class="keyword">return</span> </span><br><span class="line">            <span class="comment"># 进入左子树</span></span><br><span class="line">            postorder(root.left,li)</span><br><span class="line">            <span class="comment"># 进入右子树</span></span><br><span class="line">            postorder(root.right,li)    </span><br><span class="line">            <span class="comment"># 处理中节点</span></span><br><span class="line">            li.append(root.val)</span><br><span class="line">        li=[]</span><br><span class="line">        postorder(root,li)</span><br><span class="line">        <span class="keyword">return</span> li</span><br></pre></td></tr></table></figure>

<h3 id="2-二叉树的迭代遍历（非递归遍历）-4-12"><a href="#2-二叉树的迭代遍历（非递归遍历）-4-12" class="headerlink" title="2. 二叉树的迭代遍历（非递归遍历）(4.12)"></a>2. 二叉树的迭代遍历（非递归遍历）(4.12)</h3><h4 id="为什么非递归可以？"><a href="#为什么非递归可以？" class="headerlink" title="为什么非递归可以？"></a>为什么非递归可以？</h4><p>原因是递归的实现就是:<strong>每一次递归调用就会把函数的局部变量,参数值和返回地址等压入调用栈</strong>中,然后<strong>递归返回的时候,就从栈顶弹出上一次递归的各项参数</strong>,所以这就是为什么递归可以返回上一层的位置.(<strong>栈这里的核心作用就是返回上一层的位置</strong>)</p>
<h4 id="1-144-二叉树的前序遍历-4-12"><a href="#1-144-二叉树的前序遍历-4-12" class="headerlink" title="(1)144. 二叉树的前序遍历(4.12)"></a>(1)<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a>(4.12)</h4><h5 id="前序遍历非递归的思路："><a href="#前序遍历非递归的思路：" class="headerlink" title="前序遍历非递归的思路："></a>前序遍历非递归的思路：</h5><p>先遍历中,然后处理中节点,放入要返回的数组中;</p>
<p>紧接着改变方向-&gt;放入右孩子,接着是左孩子;</p>
<p><strong>为什么不是先做孩子再右孩子?</strong></p>
<p>原因是这个左右是遍历的顺序,而不是处理的顺序,<strong>真正处理的时候是栈弹出元素的顺序,也就是先左再右.</strong></p>
<h5 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h5><p>java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 1.递归</span></span><br><span class="line">    <span class="comment">// public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; result = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     preOrder(root,result);</span></span><br><span class="line">    <span class="comment">//     return result;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// public void preOrder(TreeNode node,List&lt;Integer&gt; result)&#123;</span></span><br><span class="line">    <span class="comment">//     if(node == null)&#123;</span></span><br><span class="line">    <span class="comment">//         return;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //前序</span></span><br><span class="line">    <span class="comment">//     // 中</span></span><br><span class="line">    <span class="comment">//     result.add(node.val);</span></span><br><span class="line">    <span class="comment">//     // 左</span></span><br><span class="line">    <span class="comment">//     preOrder(node.left,result);</span></span><br><span class="line">    <span class="comment">//     // 右</span></span><br><span class="line">    <span class="comment">//     preOrder(node.right,result);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.非递归</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//返回的结果</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//栈</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="comment">// 只要栈不为空。</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//获取栈顶元素-根节点,放入result之中</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result.add(cur.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右孩子，左孩子入站;</span></span><br><span class="line">            stack.push(cur.right);</span><br><span class="line">            stack.push(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 1.递归</span></span><br><span class="line">    <span class="comment"># def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:</span></span><br><span class="line">    <span class="comment">#     def preOrder(root,li):</span></span><br><span class="line">    <span class="comment">#         // 终止条件，节点是None</span></span><br><span class="line">    <span class="comment">#         if root == None:</span></span><br><span class="line">    <span class="comment">#             return </span></span><br><span class="line">    <span class="comment">#         // 将中节点val插入li</span></span><br><span class="line">    <span class="comment">#         li.append(root.val)</span></span><br><span class="line">    <span class="comment">#         //进入左子树</span></span><br><span class="line">    <span class="comment">#         preOrder(root.left,li)</span></span><br><span class="line">    <span class="comment">#         //进入右子树</span></span><br><span class="line">    <span class="comment">#         preOrder(root.right,li)</span></span><br><span class="line">    <span class="comment">#     li = []</span></span><br><span class="line">    <span class="comment">#     preOrder(root,li)</span></span><br><span class="line">    <span class="comment">#     return li</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.非递归</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 栈</span></span><br><span class="line">        stack = [root,]</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 只要栈不为空,下面两种写法都可以</span></span><br><span class="line">		 <span class="keyword">while</span> stack:</span><br><span class="line">        <span class="comment"># while len(stack) &gt; 0:</span></span><br><span class="line">            <span class="comment"># 取出栈顶元素</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            <span class="comment"># 节点非空加入结果中</span></span><br><span class="line">            <span class="keyword">if</span> node:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 接着进入右孩子，左孩子</span></span><br><span class="line">            stack.append(node.right)</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-94-二叉树的中序遍历-4-12"><a href="#2-94-二叉树的中序遍历-4-12" class="headerlink" title="(2)94. 二叉树的中序遍历(4.12)"></a>(2)<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a>(4.12)</h4><h5 id="思路-31"><a href="#思路-31" class="headerlink" title="思路"></a>思路</h5><p>先一路向左,降到最左的节点,然后处理根节点,如果右节点不为空,进入右侧部分</p>
<p>接着循环.</p>
<h5 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h5><p>java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//1.递归</span></span><br><span class="line">    <span class="comment">// public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     inorder(root,res);</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// public void inorder(TreeNode root,List&lt;Integer&gt; res ) &#123;</span></span><br><span class="line">    <span class="comment">//     // 终止条件，root是null的时候</span></span><br><span class="line">    <span class="comment">//     if(root == null) return;</span></span><br><span class="line">    <span class="comment">//     //进入左子树</span></span><br><span class="line">    <span class="comment">//     inorder(root.left,res);</span></span><br><span class="line">    <span class="comment">//     // 处理中节点</span></span><br><span class="line">    <span class="comment">//     res.add(root.val);</span></span><br><span class="line">    <span class="comment">//     //进入右子树</span></span><br><span class="line">    <span class="comment">//     inorder(root.right,res);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.非递归</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 栈   保存遍历结果</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span>  <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// cur 用来处理</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈不为空或者指针不为空</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()||cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 一路向左，进入最左节点</span></span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="comment">// 进入右子树</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) cur = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 1.递归</span></span><br><span class="line">    <span class="comment"># def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:</span></span><br><span class="line">    <span class="comment">#     def inorder(root,li):</span></span><br><span class="line">    <span class="comment">#         # if root == None: return</span></span><br><span class="line">    <span class="comment">#         if not root: return</span></span><br><span class="line">    <span class="comment">#         #进入左子树</span></span><br><span class="line">    <span class="comment">#         inorder(root.left,li)</span></span><br><span class="line">    <span class="comment">#         #处理中节点</span></span><br><span class="line">    <span class="comment">#         li.append(root.val)</span></span><br><span class="line">    <span class="comment">#         #进入右子树</span></span><br><span class="line">    <span class="comment">#         inorder(root.right,li)</span></span><br><span class="line">    <span class="comment">#     li = []</span></span><br><span class="line">    <span class="comment">#     inorder(root,li)</span></span><br><span class="line">    <span class="comment">#     return li</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.非递归中序（方法一）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 中序不需要写</span></span><br><span class="line">        <span class="comment"># 处理空节点</span></span><br><span class="line">        <span class="comment"># if not root: return</span></span><br><span class="line">        <span class="comment"># 栈   用来记录遍历过的元素（还没处理）</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="comment"># cur指针用来处理元素</span></span><br><span class="line">        cur = root</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 栈不为空或者cur指针不为空</span></span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="comment"># 指针不为空，先一路向左</span></span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="comment"># 入栈</span></span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="comment"># 处理根节点</span></span><br><span class="line">            node = stack.pop()</span><br><span class="line">            result.append(node.val)</span><br><span class="line">            <span class="comment"># 判断右节点,进入右子树</span></span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                <span class="comment"># 修改cur</span></span><br><span class="line">                cur = node.right</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>



<h4 id="3-145-二叉树的后序遍历-4-12"><a href="#3-145-二叉树的后序遍历-4-12" class="headerlink" title="(3)145. 二叉树的后序遍历(4.12)"></a>(3)<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a>(4.12)</h4><h5 id="思路-32"><a href="#思路-32" class="headerlink" title="思路"></a>思路</h5><p><strong>思路一</strong>: 借助前序遍历的代码,中左右,调换后面 变成中右左-&gt;翻转变成左右中</p>
<h5 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.递归</span></span><br><span class="line">    <span class="comment">// public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     postorder(root,res);</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// public void postorder(TreeNode root,List&lt;Integer&gt; res) &#123;</span></span><br><span class="line">    <span class="comment">//     // 终止条件</span></span><br><span class="line">    <span class="comment">//     if (root == null) return;</span></span><br><span class="line">    <span class="comment">//     //进入左子树</span></span><br><span class="line">    <span class="comment">//     postorder(root.left,res);</span></span><br><span class="line">    <span class="comment">//     //进入右子树</span></span><br><span class="line">    <span class="comment">//     postorder(root.right,res);</span></span><br><span class="line">    <span class="comment">//     //处理根节点</span></span><br><span class="line">    <span class="comment">//     res.add(root.val);</span></span><br><span class="line">    <span class="comment">// &#125;   </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.非递归（一）利用前序遍历的代码进行改进</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//防范空节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 栈</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 根节点入栈</span></span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="comment">// 节点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;</span><br><span class="line">                result.add(node.val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//放置左孩子，右孩子</span></span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果翻转</span></span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    # 1.递归</span><br><span class="line">    # def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line">    #     def postorder(root,li):</span><br><span class="line">    #         if not root : return </span><br><span class="line">    #         # 进入左子树</span><br><span class="line">    #         postorder(root.left,li)</span><br><span class="line">    #         # 进入右子树</span><br><span class="line">    #         postorder(root.right,li)    </span><br><span class="line">    #         # 处理中节点</span><br><span class="line">    #         li.append(root.val)</span><br><span class="line">    #     li=[]</span><br><span class="line">    #     postorder(root,li)</span><br><span class="line">    #     return li</span><br><span class="line"></span><br><span class="line">    # 2.非递归思路一</span><br><span class="line">    def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:</span><br><span class="line">    	# 防范空</span><br><span class="line">     	if not root : return </span><br><span class="line">        # 栈</span><br><span class="line">        stack = [root,]</span><br><span class="line">        # 返回结果</span><br><span class="line">        result = []</span><br><span class="line">        # 只要栈不为空</span><br><span class="line">        while stack:</span><br><span class="line">            # 弹出栈顶元素</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            if node:</span><br><span class="line">                result.append(node.val)</span><br><span class="line">            else:</span><br><span class="line">                continue</span><br><span class="line">            # 进入左右节点</span><br><span class="line">            stack.append(node.left)</span><br><span class="line">            stack.append(node.right)</span><br><span class="line">        return result[::-1]</span><br></pre></td></tr></table></figure>

<h3 id="3、二叉树层序遍历"><a href="#3、二叉树层序遍历" class="headerlink" title="3、二叉树层序遍历"></a>3、二叉树层序遍历</h3><h4 id="1-102-二叉树的层序遍历-4-13"><a href="#1-102-二叉树的层序遍历-4-13" class="headerlink" title="(1)102. 二叉树的层序遍历(4.13)"></a>(1)<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>(4.13)</h4><p>已解答</p>
<p>中等</p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/tree1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/tree1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[3],[9,20],[15,7]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<h5 id="思路-33"><a href="#思路-33" class="headerlink" title="思路"></a>思路</h5><p>如果不为空，先将根节点加入队列中，然后这是第一层，只要队列不为空循环：</p>
<p>首先记录有多个元素，进行循环遍历，将这一层的节点加入到保存这一层的数据结构中，然后如果左右子节点不为空，加入队列中。这一层结束后，将保存的结果放入总的result中。</p>
<h5 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h5><h6 id="java代码-25"><a href="#java代码-25" class="headerlink" title="java代码"></a>java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 队列</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断根节点是否为空，尾部添加（队首）</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始层序遍历,只要队列不为空</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 保存这一层的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">// 保存这一层的元素</span></span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 循环将他们size范围内的子节点全部放入队列中</span></span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 处理该层节点</span></span><br><span class="line">                res.add(node.val);</span><br><span class="line">                <span class="comment">// 处理左右孩子节点</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            result.add(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="python代码-24"><a href="#python代码-24" class="headerlink" title="python代码"></a>python代码</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrder</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 队列</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment"># 判断根节点元素</span></span><br><span class="line">        <span class="keyword">if</span> root: queue.appendleft(root)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 循环遍历,只要队列不为空</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 保存这一层有多少个元素</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment"># 保存这一层的所有元素</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="comment"># 只要这一层还有元素</span></span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                node = queue.pop()</span><br><span class="line">                <span class="comment"># 处理元素</span></span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="comment"># 处理左右子节点</span></span><br><span class="line">                <span class="keyword">if</span> node.left: queue.appendleft(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.appendleft(node.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 将这一层的结果放入</span></span><br><span class="line">            result.append(res)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>python队列</p>
<p>入队 appendleft()</p>
<p>出队 pop()</p>
<p> appendleft(a), appendleft(b), appendleft(c) -&gt; c b a</p>
<p>pop(),pop() -&gt; a b </p>
<p>剩余 c</p>
<h4 id="2-107-二叉树的层序遍历-II-4-14"><a href="#2-107-二叉树的层序遍历-II-4-14" class="headerlink" title="(2)107. 二叉树的层序遍历 II(4.14)"></a>(2)<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a>(4.14)</h4><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：[[15,7],[9,20],[3]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h5 id="思路-34"><a href="#思路-34" class="headerlink" title="思路"></a>思路</h5><p>二叉树层序遍历倒序输出</p>
<h5 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h5><h6 id="java代码-26"><a href="#java代码-26" class="headerlink" title="java代码"></a>java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrderBottom</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回结果 </span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 队列</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 判断根节点是否为空，不为空加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="comment">// 只要队列不为空，循环下去</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 计算这一层的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">// 暂存集合</span></span><br><span class="line">            List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 只弹出size个节点</span></span><br><span class="line">            <span class="keyword">while</span>(size-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 弹出队列元素</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 处理val</span></span><br><span class="line">                res.add(node.val);</span><br><span class="line">                <span class="comment">// 处理左右孩子</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将这一层的节点加入result中</span></span><br><span class="line">            result.add(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 翻转集合</span></span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="python代码-25"><a href="#python代码-25" class="headerlink" title="python代码"></a>python代码</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 队列</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment"># 如果根节点不为空，入队</span></span><br><span class="line">        <span class="keyword">if</span> root: queue.appendleft(root)</span><br><span class="line">        <span class="comment"># 只要队列不为空，一直循环</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 这一层元素个数</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="comment"># 保存该层结果</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="comment"># 处理该层每一个元素</span></span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 弹出元素</span></span><br><span class="line">                node = queue.pop()</span><br><span class="line">                <span class="comment"># 处理val，加入res</span></span><br><span class="line">                res.append(node.val)</span><br><span class="line">                <span class="comment"># 如果左右节点不为空，加入队列</span></span><br><span class="line">                <span class="keyword">if</span> node.left: queue.appendleft(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.appendleft(node.right)</span><br><span class="line">                <span class="comment"># 注意只弹出size个元素</span></span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            <span class="comment"># 处理该层结果，加入result中</span></span><br><span class="line">            result.append(res)</span><br><span class="line">        <span class="comment"># 本题要求从底层开始遍历，所以结果翻转即可</span></span><br><span class="line">        <span class="keyword">return</span> result[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="3-199-二叉树的右视图-4-14"><a href="#3-199-二叉树的右视图-4-14" class="headerlink" title="(3)199. 二叉树的右视图(4.14)"></a>(3)<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a>(4.14)</h4><p>已解答</p>
<p>中等</p>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/tree.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/tree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,null,5,null,4]</span><br><span class="line">输出: [1,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,null,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: []</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[0,100]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h5 id="思路-35"><a href="#思路-35" class="headerlink" title="思路"></a>思路</h5><p>注意：最右侧看到的元素，有可能是在最左侧，所以这些节点都要保存到队列中，只需要将size &#x3D;&#x3D; 0（该层最后一个元素）的时候</p>
<h5 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h5><h6 id="java代码-27"><a href="#java代码-27" class="headerlink" title="java代码"></a>java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        List&lt;Integer&gt; result =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 判断根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) queue.offer(root);</span><br><span class="line">        <span class="comment">// 队列不为空，一直遍历</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">// 该层元素个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="comment">// 处理该层元素</span></span><br><span class="line">            <span class="keyword">while</span>(size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 最右侧看到的元素，有可能是在最左侧，所以这些节点都要保存到队列中</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">                <span class="comment">// 只处理最右侧的节点即可</span></span><br><span class="line">                <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// 处理val</span></span><br><span class="line">                    result.add(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="python代码-26"><a href="#python代码-26" class="headerlink" title="python代码"></a>python代码</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rightSideView</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 返回结果</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="comment"># 队列</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment"># 根节点</span></span><br><span class="line">        <span class="keyword">if</span> root : queue.appendleft(root)</span><br><span class="line">        <span class="comment"># 队列不为空</span></span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="comment"># 计算size</span></span><br><span class="line">            size = <span class="built_in">len</span>(queue)</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                node = queue.pop()</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.appendleft(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.appendleft(node.right)</span><br><span class="line">                <span class="comment"># 只有size 是 1的时候，才加入result</span></span><br><span class="line">                <span class="keyword">if</span> size == <span class="number">1</span>: result.append(node.val)</span><br><span class="line">                <span class="comment"># 注意size</span></span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240414193951665.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240414193951665.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240414193951665"></p>
<h3 id="4、226-翻转二叉树-4-14"><a href="#4、226-翻转二叉树-4-14" class="headerlink" title="4、226. 翻转二叉树(4.14)"></a>4、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a>(4.14)</h3><p>已解答</p>
<p>简单</p>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/invert1-tree.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/invert1-tree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,6,9]</span><br><span class="line">输出：[4,7,2,9,6,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在 <code>[0, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="思路-36"><a href="#思路-36" class="headerlink" title="思路"></a>思路</h4><p><strong>递归遍历</strong></p>
<p>注意只要把每⼀个节点的左右孩⼦翻转⼀下，就可以达到整体翻转的效果<br>这道题⽬使⽤前序遍历和后序遍历都可以，唯独中序遍历不⽅便，因为中序遍历会把某些节点的左右孩⼦翻转了两次！建议拿纸画⼀画，就理解了。</p>
<p><strong>层序遍历</strong>依然可以的！只要把每⼀个节点的左右孩⼦翻转⼀下的遍历⽅式都是可以的！</p>
<h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-4-16"><a href="#java代码-4-16" class="headerlink" title="java代码(4.16)"></a>java代码(4.16)</h5><h6 id="1-递归方法"><a href="#1-递归方法" class="headerlink" title="1.递归方法"></a>1.递归方法</h6><p>​	(1)前序遍历顺序思路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 1.递归</span><br><span class="line">    // (1)前序</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        invert(root);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">    public void invert(TreeNode node)&#123;</span><br><span class="line">        if (node == null) return ;</span><br><span class="line">        // 交换根节点的左右</span><br><span class="line">        TreeNode tmp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = tmp;</span><br><span class="line">        // 进入左右节点</span><br><span class="line">        invert(node.left);</span><br><span class="line">        invert(node.right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	(2)后序遍历顺序思路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // (2)后序</span><br><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    invert(root);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">public void invert(TreeNode node)&#123;</span><br><span class="line">    if (node == null) return ;</span><br><span class="line">    </span><br><span class="line">    // 进入左右节点</span><br><span class="line">    invert(node.left);</span><br><span class="line">    invert(node.right);</span><br><span class="line">    // 交换根节点的左右</span><br><span class="line">    TreeNode tmp = node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	(3)中序遍历顺序思路</p>
<p>  按照前后序的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (3)中序&lt;1&gt;</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    invert(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invert</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入左节点</span></span><br><span class="line">    invert(node.left);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换根节点的左右</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node.left;</span><br><span class="line">    node.left = node.right;</span><br><span class="line">    node.right = tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入右节点</span></span><br><span class="line">    <span class="comment">// 右节点经过交换之后变为左节点了</span></span><br><span class="line">    invert(node.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-非递归方法"><a href="#2-非递归方法" class="headerlink" title="2.非递归方法"></a>2.非递归方法</h6><p>(1)前序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 2.非递归-栈</span><br><span class="line">    // 前序</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return root;</span><br><span class="line">        // 栈</span><br><span class="line">        LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">        // 栈不为空，根节点入栈</span><br><span class="line">        // 临时节点</span><br><span class="line">        TreeNode node,tmp;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        while(!stack.isEmpty())&#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line"></span><br><span class="line">            // 中</span><br><span class="line">            tmp = node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = tmp;</span><br><span class="line">            // 左右</span><br><span class="line">            if(node.left != null) stack.push(node.left);</span><br><span class="line">            if(node.right != null) stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>(2)中序</p>
<p>&lt;1&gt;基于前序和后序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// (2)中序</span><br><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    if (root == null) return root;</span><br><span class="line">    // 栈</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">    // 栈不为空，根节点入栈</span><br><span class="line">    // 临时节点</span><br><span class="line">    TreeNode node,tmp;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        node = stack.pop();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        // 左</span><br><span class="line">        if(node.left != null) stack.push(node.left);</span><br><span class="line">        // 中</span><br><span class="line">        tmp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = tmp;</span><br><span class="line">        // 右交换后就是左</span><br><span class="line">        if(node.left != null) stack.push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt;原始的中序——一路向左</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//(2)中序</span><br><span class="line">   // &lt;2&gt;一路向左的传统中序</span><br><span class="line">   public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">       if (root == null) return root;</span><br><span class="line">       // 栈</span><br><span class="line">       LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">       // 栈不为空，根节点入栈</span><br><span class="line">       // 临时节点</span><br><span class="line">       TreeNode node,tmp,cur;</span><br><span class="line">       cur = root;</span><br><span class="line">       while(!stack.isEmpty()||cur != null)&#123;</span><br><span class="line">           // 一路向左</span><br><span class="line">           while(cur != null)&#123;</span><br><span class="line">               stack.push(cur);</span><br><span class="line">               // 向左</span><br><span class="line">               cur = cur.left;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           node = stack.pop();</span><br><span class="line">           // 中</span><br><span class="line">           tmp = node.left;</span><br><span class="line">           node.left = node.right;</span><br><span class="line">           node.right = tmp;</span><br><span class="line">           </span><br><span class="line">           // 右交换后就是左,不需要入栈，只需要改变方向即可</span><br><span class="line">           if(node.left != null) cur = node.left;</span><br><span class="line">       &#125;</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>(3)后序遍历</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// (3)后序</span><br><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">    if (root == null) return root;</span><br><span class="line">    // 栈</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">    // 栈不为空，根节点入栈</span><br><span class="line">    // 临时节点</span><br><span class="line">    TreeNode node,tmp;</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while(!stack.isEmpty())&#123;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        // 左右</span><br><span class="line">        if(node.left != null) stack.push(node.left);</span><br><span class="line">        if(node.right != null) stack.push(node.right);</span><br><span class="line">        // 中</span><br><span class="line">        tmp = node.left;</span><br><span class="line">        node.left = node.right;</span><br><span class="line">        node.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-层次遍历方法"><a href="#3-层次遍历方法" class="headerlink" title="3.层次遍历方法"></a>3.层次遍历方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//4.层序——队列</span><br><span class="line">    public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return root;</span><br><span class="line">        // 队列</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        int size;</span><br><span class="line">        TreeNode node,tmp;</span><br><span class="line">        // add</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        // 队列不为空</span><br><span class="line">        while(!queue.isEmpty())&#123;</span><br><span class="line">            // 记录size大小</span><br><span class="line">            size = queue.size();</span><br><span class="line">            // 处理本层元素</span><br><span class="line">            while(size-- &gt; 0)&#123;</span><br><span class="line">                node = queue.poll();</span><br><span class="line">                // 中翻转</span><br><span class="line">                tmp = node.left;</span><br><span class="line">                node.left = node.right;</span><br><span class="line">                node.right = tmp;</span><br><span class="line"></span><br><span class="line">                // 左和右</span><br><span class="line">                if(node.left!= null) queue.offer(node.left);</span><br><span class="line">                if(node.right!= null) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416131827067.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416131827067.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416131827067"></p>
<h5 id="python代码-27"><a href="#python代码-27" class="headerlink" title="python代码"></a>python代码</h5><h6 id="1-递归方法-1"><a href="#1-递归方法-1" class="headerlink" title="1.递归方法"></a>1.递归方法</h6><p>​	(1)前序遍历顺序思路</p>
<p>​	(2)后序遍历顺序思路</p>
<p>​	(3)中序遍历顺序思路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 1.递归方法</span><br><span class="line">def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:</span><br><span class="line">    def invert(root):</span><br><span class="line">        # 终止条件</span><br><span class="line">        if not root: return root</span><br><span class="line">        # # (1)前序遍历顺序思路</span><br><span class="line">        # # 中,交换左右两个节点</span><br><span class="line">        # tmp = root.left</span><br><span class="line">        # root.left = root.right</span><br><span class="line">        # root.right = tmp</span><br><span class="line">        # # 左</span><br><span class="line">        # invert(root.left)</span><br><span class="line">        # # 右</span><br><span class="line">        # invert(root.right)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        # # (2)后序遍历顺序思路</span><br><span class="line">        # # 左</span><br><span class="line">        # invert(root.left)</span><br><span class="line">        # # 右</span><br><span class="line">        # invert(root.right)</span><br><span class="line">        # # 中,交换左右两个节点</span><br><span class="line">        # tmp = root.left</span><br><span class="line">        # root.left = root.right</span><br><span class="line">        # root.right = tmp</span><br><span class="line"></span><br><span class="line">        # (3)中序遍历顺序思路</span><br><span class="line">        # 左</span><br><span class="line">        invert(root.left)</span><br><span class="line">        # 中,交换左右两个节点</span><br><span class="line">        tmp = root.left</span><br><span class="line">        root.left = root.right</span><br><span class="line">        root.right = tmp</span><br><span class="line">        # 左！！</span><br><span class="line">        invert(root.left)#因为前面已经把root左侧的交换了，但是中序在交换了左右节点，</span><br><span class="line">        # 所以没有处理的一侧还在左侧</span><br><span class="line"></span><br><span class="line">        # 返回根节点</span><br><span class="line">        return root</span><br><span class="line">    return invert(root)</span><br></pre></td></tr></table></figure>



<h6 id="2-非递归方法-1"><a href="#2-非递归方法-1" class="headerlink" title="2.非递归方法"></a>2.非递归方法</h6><p>(1)前序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 2.非递归遍历</span><br><span class="line">    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:</span><br><span class="line">        # 栈</span><br><span class="line">        stack = []</span><br><span class="line">        # 根节点非空</span><br><span class="line">        if root : stack.append(root)</span><br><span class="line">        # 栈不为空</span><br><span class="line">        while len(stack) &gt; 0:</span><br><span class="line">            # 出栈处理</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            # # (1)前序</span><br><span class="line">            # 交换左右节点</span><br><span class="line">            node.left,node.right = node.right,node.left</span><br><span class="line">            # 左右节点入栈</span><br><span class="line">            if node.right: stack.append(node.right)</span><br><span class="line">            if node.left: stack.append(node.left)</span><br><span class="line"></span><br><span class="line">        return root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(2) 中序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># 2.非递归，中序遍历</span><br><span class="line">    # def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:</span><br><span class="line">    #     # 栈</span><br><span class="line">    #     stack = []</span><br><span class="line">    #     # 根节点不为空</span><br><span class="line">    #     if root: stack.append(root)</span><br><span class="line">    #     # 指针</span><br><span class="line">    #     cur = root</span><br><span class="line">    #     # 栈不为空,或者指针不为空</span><br><span class="line">    #     while cur or len(stack) &gt; 0:</span><br><span class="line">    #         # 一路向左</span><br><span class="line">    #         while cur:</span><br><span class="line">    #             # 入栈节点</span><br><span class="line">    #             stack.append(cur)</span><br><span class="line">    #             # 进入左孩子</span><br><span class="line">    #             cur = cur.left</span><br><span class="line">            </span><br><span class="line">    #         # 处理中节点</span><br><span class="line">    #         node = stack.pop()</span><br><span class="line">    #         # 交换左右孩子</span><br><span class="line">    #         node.left,node.right = node.right,node.left</span><br><span class="line"></span><br><span class="line">    #         cur = node.right</span><br><span class="line"></span><br><span class="line">    #         # 错误写法，上面已经交换了左右孩子，所以这里仍然要处理左孩子</span><br><span class="line">    #         # 判断右孩子是否为空,进入右孩子部分</span><br><span class="line">    #         # if node.right: cur = node.right</span><br><span class="line">            </span><br><span class="line">    #         # 正确写法</span><br><span class="line">    #         # if node.left: cur = node.left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    #     return root</span><br><span class="line">    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:</span><br><span class="line">        # 栈</span><br><span class="line">        stack = []</span><br><span class="line">        # 指针</span><br><span class="line">        cur = root</span><br><span class="line">        # 栈不为空,或者指针不为空</span><br><span class="line">        while cur or len(stack) &gt; 0:</span><br><span class="line">            # 一路向左</span><br><span class="line">            while cur:</span><br><span class="line">                # 入栈节点</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                # 进入左孩子</span><br><span class="line">                cur = cur.left</span><br><span class="line">            </span><br><span class="line">            # 处理中节点</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            # 交换左右孩子</span><br><span class="line">            node.left, node.right = node.right, node.left</span><br><span class="line"></span><br><span class="line">            # 处理右孩子</span><br><span class="line">            cur = node.left</span><br><span class="line"></span><br><span class="line">        return root</span><br></pre></td></tr></table></figure>

<h6 id="错误写法"><a href="#错误写法" class="headerlink" title="错误写法"></a>错误写法</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span><br><span class="line">    <span class="comment"># 栈</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="comment"># 根节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> root: stack.append(root)</span><br><span class="line">    <span class="comment"># 指针</span></span><br><span class="line">    cur = root</span><br><span class="line">    <span class="comment"># 栈不为空,或者指针不为空</span></span><br><span class="line">    <span class="keyword">while</span> cur <span class="keyword">or</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 一路向左</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="comment"># 入栈节点</span></span><br><span class="line">            stack.append(cur)</span><br><span class="line">            <span class="comment"># 进入左孩子</span></span><br><span class="line">            cur = cur.left</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 处理中节点</span></span><br><span class="line">        node = stack.pop()</span><br><span class="line">        <span class="comment"># 交换左右孩子</span></span><br><span class="line">        node.left,node.right = node.right,node.left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 错误写法，上面已经交换了左右孩子，所以这里仍然要处理左孩子</span></span><br><span class="line">        <span class="comment"># 判断右孩子是否为空,进入右孩子部分</span></span><br><span class="line">        <span class="comment"># if node.right: cur = node.right</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 正确写法</span></span><br><span class="line">        <span class="keyword">if</span> node.left: cur = node.left</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>这里和中序遍历的代码不同，中序遍历需要判断node.right不为空，才cur转到右子树，但是对于翻转来说，右已经变为左了，而且必须去翻转左侧，如果是null，就没必要进入去翻转了。</p>
<p>(3) 后序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:</span><br><span class="line">       # 栈</span><br><span class="line">       stack = []</span><br><span class="line">       # 根节点非空</span><br><span class="line">       if root : stack.append(root)</span><br><span class="line">       # 栈不为空</span><br><span class="line">       while len(stack) &gt; 0:</span><br><span class="line">           # 出栈处理</span><br><span class="line">           # (3)后序</span><br><span class="line">           node = stack.pop()</span><br><span class="line">           </span><br><span class="line">           # 左右节点入栈</span><br><span class="line">           if node.right: stack.append(node.right)</span><br><span class="line">           if node.left: stack.append(node.left)</span><br><span class="line"></span><br><span class="line">           # 交换左右节点</span><br><span class="line">           node.left,node.right = node.right,node.left</span><br><span class="line"></span><br><span class="line">       return root</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="3-层次遍历方法-1"><a href="#3-层次遍历方法-1" class="headerlink" title="3.层次遍历方法"></a>3.层次遍历方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 3.层次遍历</span><br><span class="line">    def invertTree(self, root: Optional[TreeNode]) -&gt; Optional[TreeNode]:</span><br><span class="line">        # 队列</span><br><span class="line">        queue = deque()</span><br><span class="line">        # 根节点不为空</span><br><span class="line">        if root: queue.appendleft(root)</span><br><span class="line">        # 队列不为空</span><br><span class="line">        while len(queue) &gt; 0:</span><br><span class="line">            # 计数该层元素</span><br><span class="line">            size = len(queue)</span><br><span class="line">            # 处理size个元素</span><br><span class="line">            while size &gt; 0:</span><br><span class="line">                # 弹出队首元素</span><br><span class="line">                node = queue.pop()</span><br><span class="line">                # 交换左右两个节点</span><br><span class="line">                tmp = node.left</span><br><span class="line">                node.left = node.right</span><br><span class="line">                node.right = tmp</span><br><span class="line">                # 将左右节点加入队列</span><br><span class="line">                if node.left: queue.appendleft(node.left)</span><br><span class="line">                if node.right: queue.appendleft(node.right)</span><br><span class="line">                # 注意size</span><br><span class="line">                size -= 1</span><br><span class="line">        return root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优化</p>
<pre><code>            # 交换左右两个节点
            tmp = node.left
            node.left = node.right
            node.right = tmp
</code></pre>
<p>为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node.left,node.right = node.right,node.left</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416131827067.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416131827067.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></p>
<h3 id="5、101-对称二叉树-4-15"><a href="#5、101-对称二叉树-4-15" class="headerlink" title="5、101. 对称二叉树(4.15)"></a>5、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a>(4.15)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/1698026966-JDYPDU-image.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/1698026966-JDYPDU-image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" class="lazyload" data-srcset="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[1, 1000]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p>
<h4 id="思路-37"><a href="#思路-37" class="headerlink" title="思路"></a>思路</h4><p>考虑比较的是两个子树，先比较根节点，再比较左右节点，然后递归下去；大二叉树的左右节点就是这样，每一个节点都要这样下去，因此就是使用递归方法。</p>
<p>对于临界条件的判断，尤其是null的时候：</p>
<p>分为左右节点都为空,返回True</p>
<p>左右节点有一个为空,返回False</p>
<p>左右节点都不为空，但是val不相等，也是False;</p>
<p>最后是左右节点都不为空，且val相等，就需要比较，左子树的左节点和右子树的右节点，以及左子树的右节点和右子树的左节点，比较完后返回上一级，这其实就是后序遍历的思想。</p>
<p><strong>最后注意空root,如果直接取left和right会有操作空指针的问题</strong></p>
<h4 id="代码-35"><a href="#代码-35" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-28"><a href="#java代码-28" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left,TreeNode right)</span>&#123;</span><br><span class="line">        <span class="comment">// 空的情况</span></span><br><span class="line">        <span class="comment">// 一个为空</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span> || left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 全空</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩下的就是都不空了</span></span><br><span class="line">        <span class="comment">// 都不为空，但是值不相等</span></span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面就是值相等了</span></span><br><span class="line">        <span class="comment">// 进入左右子树的比较</span></span><br><span class="line">        <span class="keyword">return</span> compare(left.left,right.right) &amp;&amp; compare(left.right,right.left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="python代码-28"><a href="#python代码-28" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">left,right</span>):</span><br><span class="line">            <span class="comment"># 空的情况</span></span><br><span class="line">            <span class="comment"># 全空</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="comment"># 一个为空</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right != <span class="literal">None</span> <span class="keyword">or</span> left != <span class="literal">None</span> <span class="keyword">and</span> right == <span class="literal">None</span> : <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 都不为空,但是值不相同</span></span><br><span class="line">            <span class="keyword">if</span> left.val != right.val: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="comment"># 都不为空,值相同</span></span><br><span class="line">            <span class="comment"># 此时已经是两个子树了，根节点已经相同，应该判断两个节点的左右子树,</span></span><br><span class="line">            <span class="comment"># 因为是镜像所以是相应的左对右，右对左</span></span><br><span class="line">            <span class="keyword">return</span> compare(left.left,right.right) <span class="keyword">and</span> compare(left.right,right.left) </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> true</span><br><span class="line">        <span class="keyword">return</span> compare(root.left,root.right)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">            </span><br></pre></td></tr></table></figure>

<h4 id="注意：python不要再写-None-用is-None"><a href="#注意：python不要再写-None-用is-None" class="headerlink" title="注意：python不要再写 &#x3D;&#x3D; None,用is None"></a>注意：python不要再写 &#x3D;&#x3D; None,用is None</h4><h4 id="灵神写法"><a href="#灵神写法" class="headerlink" title="灵神写法"></a>灵神写法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    # 在【100. 相同的树】的基础上稍加改动</span><br><span class="line">    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool:</span><br><span class="line">        if p is None or q is None:</span><br><span class="line">            return p is q</span><br><span class="line">        return p.val == q.val and self.isSameTree(p.left, q.right) and self.isSameTree(p.right, q.left)</span><br><span class="line"></span><br><span class="line">    def isSymmetric(self, root: Optional[TreeNode]) -&gt; bool:</span><br><span class="line">        return self.isSameTree(root.left, root.right)</span><br><span class="line"></span><br><span class="line">作者：灵茶山艾府</span><br><span class="line">链接：https://leetcode.cn/problems/symmetric-tree/solutions/2015063/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-6dq5/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416004047746.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416004047746.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416004047746"></p>
<h3 id="6、104-二叉树的最大深度-4-16"><a href="#6、104-二叉树的最大深度-4-16" class="headerlink" title="6、104. 二叉树的最大深度(4.16)"></a>6、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a>(4.16)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/tmp-tree.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/tmp-tree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数量在 <code>[0, 104]</code> 区间内。</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="思路-38"><a href="#思路-38" class="headerlink" title="思路"></a>思路</h4><p>后序遍历思路，左右子树最大深度+1（先进去左子树，再进右子树，求最大值然后+1（本层））</p>
<h4 id="代码-36"><a href="#代码-36" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-29"><a href="#java代码-29" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> Deepth(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历思路</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Deepth</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(Deepth(node.left),Deepth(node.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-29"><a href="#python代码-29" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deep</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="comment"># 为空深度是0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node : <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="comment"># 左右子树深度最大值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(deep(node.left),deep(node.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> deep(root)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416230237094.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416230237094.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416230237094"></p>
<h3 id="7、111-二叉树的最小深度-4-16"><a href="#7、111-二叉树的最小深度-4-16" class="headerlink" title="7、111. 二叉树的最小深度(4.16)"></a>7、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a>(4.16)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/ex_depth.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/ex_depth.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,null,3,null,4,null,5,null,6]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="思路-39"><a href="#思路-39" class="headerlink" title="思路"></a>思路</h4><p>后序思路：<strong>注意临界条件的设置</strong></p>
<p>​	节点为空返回0；</p>
<p>​	节点左右节点是null,返回1；</p>
<p>​	节点有一个是null,返回这个不为空节点的深度+1；</p>
<p>​	全部为空，取左右子树的最小值。</p>
<h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历???"></a>前序遍历???</h4><p>​	有点复杂</p>
<p>层次遍历太简单了，没必要。</p>
<h4 id="代码-37"><a href="#代码-37" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-30"><a href="#java代码-30" class="headerlink" title="java代码"></a>java代码</h5><p>写法在不断优化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int minDepth(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return 0;</span><br><span class="line">        return deep(root);</span><br><span class="line">    &#125;</span><br><span class="line">    // 后序思路</span><br><span class="line">    // public int deep(TreeNode node)&#123;</span><br><span class="line">    //     // 临界条件</span><br><span class="line">    //     // 说明深度是1</span><br><span class="line">    //     if (node.left == null &amp;&amp; node.right == null) return 1;</span><br><span class="line">    //     if (node.left != null &amp;&amp; node.right == null) return deep(node.left) + 1;</span><br><span class="line">    //     if (node.left == null &amp;&amp; node.right != null) return deep(node.right) + 1;</span><br><span class="line">    //     // 全不为空</span><br><span class="line">    //     return Math.min(deep(node.left),deep(node.right)) + 1;</span><br><span class="line">    // &#125;</span><br><span class="line">    // 优化写法</span><br><span class="line">    //     public int deep(TreeNode node)&#123;</span><br><span class="line">    //     // 临界条件</span><br><span class="line">    //     if (node == null) return 0;</span><br><span class="line">    //     // 全是null,说明深度是1</span><br><span class="line">    //     if (node.left == null &amp;&amp; node.right == null) return 1;</span><br><span class="line">    //     // 有一个为null，返回加起来的就行，因为一个是0</span><br><span class="line">    //     if (node.left == null || node.right == null) return deep(node.left)+deep(node.right) + 1;</span><br><span class="line">    //     // 全不为空</span><br><span class="line">    //     return Math.min(deep(node.left),deep(node.right)) + 1;</span><br><span class="line">    // &#125;</span><br><span class="line"></span><br><span class="line">    // 再优化</span><br><span class="line">    public int deep(TreeNode node)&#123;</span><br><span class="line">        // 临界条件</span><br><span class="line">        if (node == null) return 0;</span><br><span class="line">        // // 全是null,说明深度是1</span><br><span class="line">        // if (node.left == null &amp;&amp; node.right == null) return 1;</span><br><span class="line">        // // 有一个为null，返回加起来的就行，因为一个是0</span><br><span class="line">        // if (node.left == null || node.right == null) return deep(node.left)+deep(node.right) + 1;</span><br><span class="line">        // 可以结合成下面的</span><br><span class="line">        return node.left == null || node.right == null ?deep(node.left)+deep(node.right) + 1 : Math.min(deep(node.left),deep(node.right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="python代码-30"><a href="#python代码-30" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minDepth</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">deep</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment"># 有一个是null(None)或者全是null</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">or</span> <span class="keyword">not</span> node.right: <span class="keyword">return</span> deep(node.left) + deep(node.right) + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 全不是null</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>(deep(node.left),deep(node.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> deep(root)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416230209964.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416230209964.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416230209964"></p>
<h3 id="8、222-完全二叉树的节点个数-4-16"><a href="#8、222-完全二叉树的节点个数-4-16" class="headerlink" title="8、222. 完全二叉树的节点个数(4.16)"></a>8、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a>(4.16)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企</p>
<p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/14/complete.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,6]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目范围是<code>[0, 5 * 104]</code></li>
<li><code>0 &lt;= Node.val &lt;= 5 * 104</code></li>
<li>题目数据保证输入的树是 <strong>完全二叉树</strong></li>
</ul>
<p><strong>进阶：</strong>遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗？</p>
<h4 id="思路-40"><a href="#思路-40" class="headerlink" title="思路"></a>思路</h4><p>普通二叉树遍历</p>
<p><strong>完全二叉树特性</strong></p>
<p>​	利用其中部分是满二叉树的特性，使得不用遍历，直接计算也可以得到节点数量</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416234023788.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240416234023788.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240416234023788"></p>
<ul>
<li>遍历左子树（一路向左），右子树（一路向右），如果高度h一致就是满二叉树，计算节点个数 &#x3D; 2^h-1</li>
<li>如果不是满二叉树正常进入左右子树，节点数量：左右子树节点之和+1（根节点）</li>
</ul>
<h4 id="代码-38"><a href="#代码-38" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-31"><a href="#java代码-31" class="headerlink" title="java代码"></a>java代码</h5><h6 id="普通二叉树-后序"><a href="#普通二叉树-后序" class="headerlink" title="普通二叉树 后序"></a>普通二叉树 后序</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cNode(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.普通二叉树(后序)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cNode</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> cNode(node.left) + cNode(node.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="完全二叉树-1"><a href="#完全二叉树-1" class="headerlink" title="完全二叉树"></a>完全二叉树</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cNode(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1.普通二叉树(后序)</span></span><br><span class="line">    <span class="comment">// public int cNode(TreeNode node)&#123;</span></span><br><span class="line">    <span class="comment">//     // 临界条件</span></span><br><span class="line">    <span class="comment">//     if (node == null) return 0;</span></span><br><span class="line">    <span class="comment">//     return cNode(node.left) + cNode(node.right) + 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 2.完全二叉树(相当于剪枝)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cNode</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">le</span> <span class="operator">=</span> node,ri = node;</span><br><span class="line">        <span class="type">int</span> hl=<span class="number">0</span>,hr=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 一路向左</span></span><br><span class="line">        <span class="keyword">while</span>(le != <span class="literal">null</span>)&#123;</span><br><span class="line">            le = le.left;</span><br><span class="line">            hl++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一路向右</span></span><br><span class="line">        <span class="keyword">while</span>(ri != <span class="literal">null</span>)&#123;</span><br><span class="line">            ri = ri.right;</span><br><span class="line">            hr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hl == hr) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>,hl) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> cNode(node.left) + cNode(node.right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="python代码-31"><a href="#python代码-31" class="headerlink" title="python代码"></a>python代码</h5><h6 id="普通二叉树-后序-1"><a href="#普通二叉树-后序-1" class="headerlink" title="普通二叉树 后序"></a>普通二叉树 后序</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 2.普通后序</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">cNode</span>(<span class="params">node</span>):</span><br><span class="line">            <span class="comment"># 临界条件</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">return</span> cNode(node.left) +  cNode(node.right) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cNode(root)</span><br></pre></td></tr></table></figure>



<h6 id="满二叉树-1"><a href="#满二叉树-1" class="headerlink" title="满二叉树"></a>满二叉树</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def countNodes(self, root: Optional[TreeNode]) -&gt; int:</span><br><span class="line">        def cNode(node):</span><br><span class="line">            # 临界条件</span><br><span class="line">            if not node: return 0</span><br><span class="line">            # 看是否是满二叉树</span><br><span class="line">            hl,hr = 0,0</span><br><span class="line">            le,ri = node,node</span><br><span class="line">            # 循环左,右两侧</span><br><span class="line">            while le:</span><br><span class="line">                le = le.left</span><br><span class="line">                hl += 1</span><br><span class="line">            while ri:</span><br><span class="line">                ri = ri.right</span><br><span class="line">                hr += 1</span><br><span class="line">            # 高度相等</span><br><span class="line">            if hl == hr : return pow(2,hl) - 1</span><br><span class="line">            return cNode(node.left) +  cNode(node.right) + 1</span><br><span class="line">        return cNode(root)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240417000336983.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240417000336983.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240417000336983"></p>
<h3 id="9、110-平衡二叉树-4-16"><a href="#9、110-平衡二叉树-4-16" class="headerlink" title="9、110. 平衡二叉树(4.16)"></a>9、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a>(4.16)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个二叉树，判断它是否是 </p>
<p>平衡二叉树</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/balance_1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/balance_1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,9,20,null,null,15,7]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,2,3,3,null,null,4,4]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<h4 id="思路-41"><a href="#思路-41" class="headerlink" title="思路"></a>思路</h4><p>就计算每一个节点高度，判断左右孩子高度差是不是小于1.</p>
<h4 id="代码-39"><a href="#代码-39" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-32"><a href="#java代码-32" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">        return isB(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isB(TreeNode root) &#123;</span><br><span class="line">        // 临界条件</span><br><span class="line">        if (root == null) return true;</span><br><span class="line">        // 前序</span><br><span class="line"></span><br><span class="line">        // 先根节点,然后左右节点</span><br><span class="line">        // if(Math.abs(deep(root.left)-deep(root.right)) &lt;= 1)&#123;</span><br><span class="line">        //     return isB(root.left) &amp;&amp; isB(root.right);</span><br><span class="line">        // &#125;</span><br><span class="line">        // return false;</span><br><span class="line"></span><br><span class="line">        // 优化写法</span><br><span class="line">        return Math.abs(deep(root.left)-deep(root.right)) &lt;= 1 &amp;&amp; isB(root.left) &amp;&amp; isB(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    // 计算树高度的</span><br><span class="line">    public int deep(TreeNode node)&#123;</span><br><span class="line">        if (node == null) return 0;</span><br><span class="line">        // 树高度是左右子树高度的最大值+1</span><br><span class="line">        return Math.max(deep(node.left),deep(node.right)) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-32"><a href="#python代码-32" class="headerlink" title="python代码"></a>python代码</h5><p>进一步优化——只用一个函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def isBalanced(self, root: Optional[TreeNode]) -&gt; bool:</span><br><span class="line">        def deep(node):</span><br><span class="line">            # 临界条件</span><br><span class="line">            if not node: return 0</span><br><span class="line">            le = deep(node.left)</span><br><span class="line">            ri = deep(node.right)</span><br><span class="line">            if le == -1 or ri == -1 :return -1</span><br><span class="line">            return max(le,ri)+ 1 if abs(le-ri) &lt;= 1 else -1</span><br><span class="line">        return deep(root) != -1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240417004705285.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240417004705285.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240417004705285"></p>
<h3 id="10、257-二叉树的所有路径-4-17"><a href="#10、257-二叉树的所有路径-4-17" class="headerlink" title="10、257. 二叉树的所有路径(4.17)"></a>10、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a>(4.17)</h3><p>简单</p>
<p>已解答</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/paths-tree.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/paths-tree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3,null,5]</span><br><span class="line">输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[&quot;1&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
</ul>
<h4 id="思路-42"><a href="#思路-42" class="headerlink" title="思路"></a>思路</h4><p>递归+回溯</p>
<p>因为路径是从根节点出发，到没有子孩子的节点，因此采取前序遍历为好。</p>
<p>回溯是要去掉递归改变的部分，所以递归一定要去改变，不然回溯没有意义。</p>
<h5 id="递归三部曲"><a href="#递归三部曲" class="headerlink" title="递归三部曲"></a>递归三部曲</h5><p><strong>参数 binaryTreePaths(node,List path,List result;)</strong></p>
<p>node是当前节点，path是目前的路径，用列表表示；result是保存所有结果的集合。</p>
<p><strong>终止条件</strong></p>
<p>​	真正的子节点：</p>
<p>​		node.left &#x3D;&#x3D; null and node.right &#x3D;&#x3D; null</p>
<p>​	<strong>保存：</strong>现在就可以保存路径了，根据保存的规则，进行遍历path的每一个元素，后面加上-&gt;</p>
<p>​	遍历结束后，加上此节点即可。</p>
<p>​	<strong>收集结果</strong>并放入result中。</p>
<h5 id="单个处理逻辑"><a href="#单个处理逻辑" class="headerlink" title="单个处理逻辑"></a>单个处理逻辑</h5><p>​	（1）将node.val放入path里面</p>
<p>​	（2）左&#x2F;右节点，如果不为空</p>
<p><strong>递归 左右节点</strong></p>
<p>​		binaryTreePaths(node.left&#x2F;node.right,path,result)</p>
<p><strong>回溯</strong>——含义就是去掉已经保存的路径，进入新的路径。</p>
<p>​	去掉path加入的val,进入右节点重复相同的操作</p>
<p><strong>返回值无</strong></p>
<h4 id="代码-40"><a href="#代码-40" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-33"><a href="#java代码-33" class="headerlink" title="java代码"></a>java代码</h5><h6 id="显式的回溯"><a href="#显式的回溯" class="headerlink" title="显式的回溯"></a>显式的回溯</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        // 路径集合</span><br><span class="line">        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br><span class="line">        // 返回结果</span><br><span class="line">        List&lt;String&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        TreePath(root,path,result);</span><br><span class="line">        return result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void TreePath(TreeNode node,List&lt;Integer&gt; path,List&lt;String&gt; result)&#123;</span><br><span class="line">        // 无论如何，先加入path</span><br><span class="line">        path.add(node.val);</span><br><span class="line">        // 临界条件</span><br><span class="line">        if (node.left == null &amp;&amp; node.right == null)&#123;</span><br><span class="line">            String s = &quot;&quot;;</span><br><span class="line">            for(int i=0;i&lt;path.size() - 1;i++)&#123;</span><br><span class="line">                s += path.get(i) + &quot;&quot;;</span><br><span class="line">                s += &quot;-&gt;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            // 拼接最后的val</span><br><span class="line">            s += path.get(path.size() - 1);</span><br><span class="line">            // 收集结果</span><br><span class="line">            result.add(s);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 左右节点</span><br><span class="line">        if(node.left != null)&#123;</span><br><span class="line">            TreePath(node.left,path,result);</span><br><span class="line">            // 回溯,删掉刚才添加的那个元素</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">        if(node.right != null)&#123;</span><br><span class="line">            TreePath(node.right,path,result);</span><br><span class="line">            // 回溯,删掉刚才添加的那个元素</span><br><span class="line">            path.remove(path.size()-1);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="隐式回溯"><a href="#隐式回溯" class="headerlink" title="隐式回溯"></a>隐式回溯</h6><p>这里使用了toSring()这种新创建String对象,用来进行递归，结束后不影响pathSB，因此隐式的完成了一次回溯。</p>
<p>也可以使用 + “”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">        List&lt;String&gt; paths = new ArrayList&lt;String&gt;();</span><br><span class="line">        constructPaths(root, &quot;&quot;, paths);</span><br><span class="line">        return paths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void constructPaths(TreeNode root, String path, List&lt;String&gt; paths) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            StringBuffer pathSB = new StringBuffer(path);</span><br><span class="line">            pathSB.append(Integer.toString(root.val));</span><br><span class="line">            if (root.left == null &amp;&amp; root.right == null) &#123;  // 当前节点是叶子节点</span><br><span class="line">                paths.add(pathSB.toString());  // 把路径加入到答案中</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                pathSB.append(&quot;-&gt;&quot;);  // 当前节点不是叶子节点，继续递归遍历</span><br><span class="line">                constructPaths(root.left, pathSB.toString(), paths);</span><br><span class="line">                constructPaths(root.right, pathSB.toString(), paths);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="另一种隐式回溯"><a href="#另一种隐式回溯" class="headerlink" title="另一种隐式回溯"></a>另一种隐式回溯</h6><p>path + “-&gt;” 将这两个一起传，构成隐式回溯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> class Solution &#123;</span><br><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">    // 回溯（String）</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; paths = new ArrayList&lt;&gt;();</span><br><span class="line">    dfs(root, &quot;&quot;, paths); // 从根节点开始dfs</span><br><span class="line">    return paths;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void dfs(TreeNode root, String path, List&lt;String&gt; paths) &#123;</span><br><span class="line">    if (root == null) &#123; // 如果节点为空，直接返回</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // path += String.valueOf(root.val);//一样</span><br><span class="line">    path += root.val; // 将当前节点的值添加到路径中</span><br><span class="line"></span><br><span class="line">    // 如果当前节点是叶子节点，那么我们找到了一个路径</span><br><span class="line">    if (root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">        paths.add(path); // 将路径添加到路径列表中</span><br><span class="line"></span><br><span class="line">    &#125; else &#123; // 如果当前节点不是叶子节点，继续在它的子节点中搜索</span><br><span class="line">        dfs(root.left, path + &quot;-&gt;&quot;, paths);</span><br><span class="line">        dfs(root.right, path + &quot;-&gt;&quot;, paths);</span><br><span class="line">        // 在Java中，字符串同样是不可变的，每次拼接操作实际上都创建了一个新的字符串对象。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-33"><a href="#python代码-33" class="headerlink" title="python代码"></a>python代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:</span><br><span class="line">        def dfs(node,path,result):</span><br><span class="line">            path.append(node.val)</span><br><span class="line">            # 终止条件，左右节点为空</span><br><span class="line">            if not node.left and not node.right: </span><br><span class="line">                # 生成路径</span><br><span class="line">                string = &quot;&quot;</span><br><span class="line">                for i in path[:-1]:</span><br><span class="line">                    string +=str(i)</span><br><span class="line">                    string +=&quot;-&gt;&quot;</span><br><span class="line">                # 最后一个节点</span><br><span class="line">                string += str(node.val)</span><br><span class="line">                # 收集结果</span><br><span class="line">                result.append(string)</span><br><span class="line">                return </span><br><span class="line">            </span><br><span class="line">            # 左右节点</span><br><span class="line">            if node.left: </span><br><span class="line"></span><br><span class="line">                # 递归</span><br><span class="line">                dfs(node.left,path,result)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">            if node.right: </span><br><span class="line"></span><br><span class="line">                # 递归</span><br><span class="line">                dfs(node.right,path,result)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line">        path,result = [],[]</span><br><span class="line">        dfs(root,path,result)</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<p>另一种写法，有点绕，所以要注意在哪里加入z</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def binaryTreePaths(self, root: Optional[TreeNode]) -&gt; List[str]:</span><br><span class="line">        def dfs(node,path,result):</span><br><span class="line">            </span><br><span class="line">            # 终止条件，左右节点为空</span><br><span class="line">            if not node.left and not node.right: </span><br><span class="line">                # 生成路径</span><br><span class="line">                string = &quot;&quot;</span><br><span class="line">                for i in path:</span><br><span class="line">                    string +=str(i)</span><br><span class="line">                    string +=&quot;-&gt;&quot;</span><br><span class="line">                # 最后一个节点</span><br><span class="line">                string += str(node.val)</span><br><span class="line">                # 收集结果</span><br><span class="line">                result.append(string)</span><br><span class="line">                return </span><br><span class="line">            path.append(node.val)</span><br><span class="line">            # 左右节点</span><br><span class="line">            if node.left: </span><br><span class="line">                # 递归</span><br><span class="line">                dfs(node.left,path,result)</span><br><span class="line">            if node.right: </span><br><span class="line">                # 递归</span><br><span class="line">                dfs(node.right,path,result)</span><br><span class="line">            path.pop()</span><br><span class="line"></span><br><span class="line">        path,result = [],[]</span><br><span class="line">        dfs(root,path,result)</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>



<h3 id="11、404-左叶子之和-4-18"><a href="#11、404-左叶子之和-4-18" class="headerlink" title="11、404. 左叶子之和(4.18)"></a>11、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a>(4.18)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/leftsum-tree.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/leftsum-tree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [3,9,20,null,null,15,7] </span><br><span class="line">输出: 24 </span><br><span class="line">解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>节点数在 <code>[1, 1000]</code> 范围内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
</ul>
<h4 id="思路-43"><a href="#思路-43" class="headerlink" title="思路"></a>思路</h4><h5 id="递归这里相当于前序。"><a href="#递归这里相当于前序。" class="headerlink" title="递归这里相当于前序。"></a>递归这里相当于前序。</h5><h5 id="不用返回值的"><a href="#不用返回值的" class="headerlink" title="不用返回值的"></a>不用返回值的</h5><p>参数 sumleft node, List<Integer>result</p>
<p>左节点处理（临界条件）</p>
<p>if node !&#x3D; null &amp;&amp; node.left !&#x3D; null &amp;&amp; node.left.left &#x3D;&#x3D; null &amp;&amp; node.left.right &#x3D;&#x3D; null</p>
<p>​	result.add(node.left.val)</p>
<p>​	return</p>
<p> sumleft(node.left,result)</p>
<p> sumleft(node.right,result)</p>
<h5 id="需要返回值的"><a href="#需要返回值的" class="headerlink" title="需要返回值的"></a>需要返回值的</h5><p>这个思路就是返回int的值。</p>
<p>左节点处理（临界条件）时，因为左侧node.left已经结束,所以只需要再加上右侧的即可。</p>
<p>对应正常情况则是，返回左右侧val相加</p>
<h5 id="迭代法——非递归"><a href="#迭代法——非递归" class="headerlink" title="迭代法——非递归"></a>迭代法——非递归</h5><p>判断条件类似</p>
<h4 id="代码-41"><a href="#代码-41" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-34"><a href="#java代码-34" class="headerlink" title="java代码"></a>java代码</h5><h6 id="一，不用返回值的"><a href="#一，不用返回值的" class="headerlink" title="一，不用返回值的"></a>一，不用返回值的</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        sumleft(root,result);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)&#123;</span><br><span class="line">            sum += result.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sumleft</span><span class="params">(TreeNode node,List&lt;Integer&gt; result)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            result.add(node.left.val);</span><br><span class="line">            <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) sumleft(node.left,result);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) sumleft(node.right,result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// return;</span></span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="二、需要返回值的"><a href="#二、需要返回值的" class="headerlink" title="二、需要返回值的"></a>二、需要返回值的</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 2.需要返回值的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sumleft(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">sumleft</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node.left.val+ sumleft(node.right);</span><br><span class="line">            <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumleft(node.left) + sumleft(node.right);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="三、迭代法"><a href="#三、迭代法" class="headerlink" title="三、迭代法"></a>三、迭代法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.迭代法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 栈、</span></span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) stack.push(root);</span><br><span class="line">    <span class="comment">// 栈不为空</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">        node = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            result += node.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-34"><a href="#python代码-34" class="headerlink" title="python代码"></a>python代码</h5><h6 id="一-没有返回值的"><a href="#一-没有返回值的" class="headerlink" title="一 .没有返回值的"></a>一 .没有返回值的</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 1.没返回值的</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sumLeft</span>(<span class="params">node,res</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 不为空,不为空，空，空</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">and</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">                res.append(node.left.val)</span><br><span class="line">            sumLeft(node.left,res)</span><br><span class="line">            sumLeft(node.right,res)</span><br><span class="line">        res = []</span><br><span class="line">        sumLeft(root,res)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(res)</span><br></pre></td></tr></table></figure>

<h6 id="二-有返回值的"><a href="#二-有返回值的" class="headerlink" title="二 .有返回值的"></a>二 .有返回值的</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.有返回值的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sumLeft</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 不为空,不为空，空，空</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">and</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">        <span class="keyword">return</span> node.left.val + sumLeft(node.right)</span><br><span class="line">    <span class="keyword">return</span> sumLeft(node.left) + sumLeft(node.right)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sumLeft(root)</span><br></pre></td></tr></table></figure>

<h6 id="三-迭代法"><a href="#三-迭代法" class="headerlink" title="三 .迭代法"></a>三 .迭代法</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3.迭代法_前序</span></span><br><span class="line"><span class="comment"># 栈</span></span><br><span class="line">stack = []</span><br><span class="line"><span class="comment"># 返回值</span></span><br><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">stack.append(root)</span><br><span class="line"><span class="comment"># 栈不空</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span>:</span><br><span class="line">    node = stack.pop()</span><br><span class="line">    <span class="keyword">if</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.left <span class="keyword">and</span> <span class="keyword">not</span> node.left.right:</span><br><span class="line">        res += node.left.val</span><br><span class="line">    <span class="keyword">if</span> node.right: stack.append(node.right)</span><br><span class="line">    <span class="keyword">if</span> node.left: stack.append(node.left)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="12、513-找树左下角的值-4-18"><a href="#12、513-找树左下角的值-4-18" class="headerlink" title="12、513. 找树左下角的值(4.18)"></a>12、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a>(4.18)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [2,1,3]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/tree2.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/tree2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>二叉树的节点个数的范围是 <code>[1,104]</code></li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h4 id="思路-44"><a href="#思路-44" class="headerlink" title="思路"></a>思路</h4><h5 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h5><p>每次记录每层第一个，后面不断替换这个值，最后保留下来的就是最后一层的第一个。</p>
<h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><p>思路就是记录每一层的深度，运用回溯的思想，每一个叶子节点就去判断有没有大于目前记录的深度，如果有就更新；后面如果也遍历到这一层，因为高度一样，所以不会出现记录其他节点的值了，而不是第一个，当已经是最大深度的时候，此时递归结束，保存的节点就是这个最底层的最左侧节点。</p>
<h4 id="代码-42"><a href="#代码-42" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-35"><a href="#java代码-35" class="headerlink" title="java代码"></a>java代码</h5><h6 id="一、层序遍历"><a href="#一、层序遍历" class="headerlink" title="一、层序遍历"></a>一、层序遍历</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 层序遍历</span></span><br><span class="line">        <span class="comment">// 队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>,res =<span class="number">0</span>,test=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            size = queue.size();</span><br><span class="line">            test = size;</span><br><span class="line">            <span class="comment">// 弹出size个</span></span><br><span class="line">            <span class="keyword">while</span>(size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                node = queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(size == test)  res=node.val;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h6 id="二、递归"><a href="#二、递归" class="headerlink" title="二、递归"></a>二、递归</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">Deep</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2.递归，回溯</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        findv(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findv</span><span class="params">(TreeNode node,<span class="type">int</span> deep)</span>&#123;</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(deep &gt; Deep)&#123;</span><br><span class="line">                <span class="comment">// 保存新高度和节点</span></span><br><span class="line">                Deep = deep;</span><br><span class="line">                value = node.val;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) findv(node.left,deep + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) findv(node.right,deep + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h5 id="python代码-35"><a href="#python代码-35" class="headerlink" title="python代码"></a>python代码</h5><h6 id="一、层序遍历-1"><a href="#一、层序遍历-1" class="headerlink" title="一、层序遍历"></a>一、层序遍历</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 1.层序遍历</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 队列</span></span><br><span class="line">        queue = deque()</span><br><span class="line">        <span class="comment"># 结果</span></span><br><span class="line">        val = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root : queue.appendleft(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                node = queue.pop()</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>: val = node.val</span><br><span class="line">                <span class="keyword">if</span> node.left: queue.appendleft(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right: queue.appendleft(node.right)</span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure>

<h6 id="二、递归-回溯"><a href="#二、递归-回溯" class="headerlink" title="二、递归+回溯"></a>二、递归+回溯</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2.递归加回溯</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">findv</span>(<span class="params">node,deep</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> Deep,val</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 叶子节点</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="keyword">if</span> deep &gt; Deep:</span><br><span class="line">                    Deep = deep</span><br><span class="line">                    val = node.val</span><br><span class="line">            findv(node.left,deep+<span class="number">1</span>)</span><br><span class="line">            findv(node.right,deep+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        Deep = -<span class="number">1</span></span><br><span class="line">        val = <span class="number">0</span></span><br><span class="line">        findv(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> val</span><br></pre></td></tr></table></figure>



<h3 id="13、112-路径总和-4-18"><a href="#13、112-路径总和-4-18" class="headerlink" title="13、112. 路径总和(4.18)"></a>13、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a>(4.18)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class="line">输出：true</span><br><span class="line">解释：等于目标和的根节点到叶节点路径如上图所示。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/pathsum2.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/pathsum2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：false</span><br><span class="line">解释：树中存在两条根节点到叶子节点的路径：</span><br><span class="line">(1 --&gt; 2): 和为 3</span><br><span class="line">(1 --&gt; 3): 和为 4</span><br><span class="line">不存在 sum = 5 的根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [], targetSum = 0</span><br><span class="line">输出：false</span><br><span class="line">解释：由于树是空的，所以不存在根节点到叶子节点的路径。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h4 id="思路-45"><a href="#思路-45" class="headerlink" title="思路"></a>思路</h4><h5 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h5><p>使用了全局变量</p>
<p>确定临界条件，必须是叶子节点同时sum&#x3D;&#x3D;targetsum才修改flag</p>
<p>正常节点处理思路是 进不为空的左右子节点，用回溯的方法</p>
<p><strong>注意：</strong>这里的sum是在传的时候就把本节点的val加了，所以回溯的时候会简单一点，直接+node.val即可。</p>
<p>if (node.left !&#x3D; null) hasPath(node.left, sum + node.left.val,targetSum);<br>if (node.right !&#x3D; null) hasPath(node.right, sum + node.right.val,targetSum);</p>
<h5 id="carl思路"><a href="#carl思路" class="headerlink" title="carl思路"></a>carl思路</h5><p>递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a target="_blank" rel="noopener" href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li>
</ul>
<p>图中可以看出，遍历的路线，并不要遍历整棵树，所以递归函数需要返回值，可以用bool类型表示。</p>
<p>所以代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(treenode* cur, <span class="type">int</span> count)</span>   <span class="comment">// 注意函数的返回类型</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>确定终止条件</li>
</ol>
<p>首先计数器如何统计这一条路径的和呢？</p>
<p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p>
<p>如果最后count &#x3D;&#x3D; 0，同时到了叶子节点的话，说明找到了目标和。</p>
<p>如果遍历到了叶子节点，count不为0，就是没找到。</p>
<p>递归终止条件代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line"><span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点而没有找到合适的边，直接返回</span></span><br></pre></td></tr></table></figure>

<p>​	2.确定单层递归的逻辑</p>
<p>因为终止条件是判断叶子节点，所以递归的过程中就不要让空节点进入递归了。</p>
<p>递归函数是有返回值的，如果递归函数返回true，说明找到了合适的路径，应该立刻返回。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count - cur-&gt;left-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右 （空节点不遍历）</span></span><br><span class="line">    <span class="comment">// 遇到叶子节点返回true，则直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count - cur-&gt;right-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 注意这里有回溯的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>以上代码中是包含着回溯的，没有回溯，如何后撤重新找另一条路径呢。</p>
<p>回溯隐藏在<code>traversal(cur-&gt;left, count - cur-&gt;left-&gt;val)</code>这里， 因为把<code>count - cur-&gt;left-&gt;val</code> 直接作为参数传进去，函数结束，count的数值没有改变。</p>
<p>为了把回溯的过程体现出来，可以改为如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">    count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">    count -= cur-&gt;right-&gt;val;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    count += cur-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>整体代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, <span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 遇到叶子节点，并且计数为0</span></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遇到叶子节点直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;left) &#123; <span class="comment">// 左</span></span><br><span class="line">            count -= cur-&gt;left-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;left, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;left-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;right) &#123; <span class="comment">// 右</span></span><br><span class="line">            count -= cur-&gt;right-&gt;val; <span class="comment">// 递归，处理节点;</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">traversal</span>(cur-&gt;right, count)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            count += cur-&gt;right-&gt;val; <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以上代码精简之后如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>是不是发现精简之后的代码，已经完全看不出分析的过程了，所以我们要把题目分析清楚之后，再追求代码精简。</strong> </p>
<h4 id="代码-43"><a href="#代码-43" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-36"><a href="#java代码-36" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        hasPath(root,root.val,targetSum);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hasPath</span><span class="params">(TreeNode node, <span class="type">int</span> sum, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right ==<span class="literal">null</span> &amp;&amp; sum == targetSum) flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span>) hasPath(node.left, sum + node.left.val,targetSum);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="literal">null</span>) hasPath(node.right, sum + node.right.val,targetSum);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="使用targetsum-val这种方式。"><a href="#使用targetsum-val这种方式。" class="headerlink" title="使用targetsum - val这种方式。"></a>使用targetsum - val这种方式。</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2.carl思路 使用返回值并且tarsum - val</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode node, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">    <span class="comment">// 空</span></span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 叶子节点满足 sum = node.val</span></span><br><span class="line">    <span class="keyword">if</span>(node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; targetSum == node.val) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常逻辑，左右节点——只要有true就传下去</span></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(node.left, targetSum - node.val) || hasPathSum(node.right, targetSum - node.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="python代码-36"><a href="#python代码-36" class="headerlink" title="python代码"></a>python代码</h5><h6 id="使用targetsum-val这种方式。-1"><a href="#使用targetsum-val这种方式。-1" class="headerlink" title="使用targetsum - val这种方式。"></a>使用targetsum - val这种方式。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, val=0, left=None, right=None):</span><br><span class="line">#         self.val = val</span><br><span class="line">#         self.left = left</span><br><span class="line">#         self.right = right</span><br><span class="line">class Solution:</span><br><span class="line">    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -&gt; bool:</span><br><span class="line">        # 空</span><br><span class="line">        if not root: return False</span><br><span class="line">        # 子节点满足条件</span><br><span class="line">        if not root.left and not root.right and targetSum == root.val:</span><br><span class="line">            return True</span><br><span class="line">        # 只要有满足的就往上层返回True</span><br><span class="line">        return self.hasPathSum(root.left,targetSum - root.val) or self.hasPathSum(root.right,targetSum - root.val)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="14、113-路径总和-II-4-19"><a href="#14、113-路径总和-II-4-19" class="headerlink" title="14、113. 路径总和 II(4.19)"></a>14、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a>(4.19)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/pathsumii1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/pathsumii1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>
<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>
<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>
</ul>
<h4 id="思路-46"><a href="#思路-46" class="headerlink" title="思路"></a>思路</h4><p>所有加的地方,一定会减回来,这样回溯才能进行下去.</p>
<h4 id="代码-44"><a href="#代码-44" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-37"><a href="#java代码-37" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private int target;</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if (root == null) return result;</span><br><span class="line">        target = targetSum;</span><br><span class="line">        int sum  = root.val;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        path(root,sum,res,result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void path(TreeNode node, int sum,List&lt;Integer&gt; res,List&lt;List&lt;Integer&gt;&gt; result) &#123;</span><br><span class="line">        // 剪枝——大于,target有小于0的，这种不合适 if(sum &gt; target) return;</span><br><span class="line">        // if(target &gt; 0 &amp;&amp; sum &gt; target) return;</span><br><span class="line"></span><br><span class="line">        // 叶子节点</span><br><span class="line">        if(node.left==null &amp;&amp; node.right == null &amp;&amp; sum == target)&#123;</span><br><span class="line">            result.add(new ArrayList&lt;&gt;(res));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (node.left!=null)&#123;</span><br><span class="line">            res.add(node.left.val);</span><br><span class="line">            path(node.left,sum + node.left.val,res,result);</span><br><span class="line">            res.remove(res.size() - 1);</span><br><span class="line">        &#125;   </span><br><span class="line">        if (node.right!=null)&#123;</span><br><span class="line">            res.add(node.right.val);</span><br><span class="line">            path(node.right,sum + node.right.val,res,result);</span><br><span class="line">            res.remove(res.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官解</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;</span><br><span class="line">        recur(root, targetSum);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void recur(TreeNode root, int tar) &#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        tar -= root.val;</span><br><span class="line">        if (tar == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null)</span><br><span class="line">            res.add(new LinkedList&lt;Integer&gt;(path));</span><br><span class="line">        recur(root.left, tar);</span><br><span class="line">        recur(root.right, tar);</span><br><span class="line">        //tar += root.val;</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的类似官解代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> target;</span><br><span class="line">    <span class="comment">// 不提前加val</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        target = targetSum;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        path(root,sum,res,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">path</span><span class="params">(TreeNode node, <span class="type">int</span> sum,List&lt;Integer&gt; res,List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sum += node.val;</span><br><span class="line">        res.add(node.val);</span><br><span class="line">        <span class="comment">// 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span> &amp;&amp; sum == target)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(res));</span><br><span class="line">            <span class="comment">// 不注释也能过,会快一点,因为满足这个条件后,node.left,node.right就调用直接返回了.</span></span><br><span class="line">            <span class="comment">// sum -= node.val;</span></span><br><span class="line">            <span class="comment">// res.remove(res.size() - 1);</span></span><br><span class="line">            <span class="comment">// return;</span></span><br><span class="line"></span><br><span class="line">        &#125;    </span><br><span class="line">        path(node.left,sum ,res,result);   </span><br><span class="line">        path(node.right,sum ,res,result);</span><br><span class="line">        sum -= node.val;</span><br><span class="line">        res.remove(res.size() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">           </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="python代码-37"><a href="#python代码-37" class="headerlink" title="python代码"></a>python代码</h5><p>基于减的方式 + 全局变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">path</span>(<span class="params">node,targetSum</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> res,result</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node: <span class="keyword">return</span></span><br><span class="line">            targetSum -= node.val</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right <span class="keyword">and</span> targetSum == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 直接引用不行，需要拷贝</span></span><br><span class="line">                <span class="comment"># result.append(res)</span></span><br><span class="line">                result.append(res.copy())</span><br><span class="line">            path(node.left,targetSum)</span><br><span class="line">            path(node.right,targetSum)</span><br><span class="line">            res.pop()</span><br><span class="line">        res = []</span><br><span class="line">        result = []</span><br><span class="line">        path(root,targetSum)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="15、106-从中序与后序遍历序列构造二叉树-4-20"><a href="#15、106-从中序与后序遍历序列构造二叉树-4-20" class="headerlink" title="15、106. 从中序与后序遍历序列构造二叉树(4.20)"></a>15、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a>(4.20)</h3><p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]</span><br><span class="line">输出：[3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：inorder = [-1], postorder = [-1]</span><br><span class="line">输出：[-1]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= inorder.length &lt;= 3000</code></li>
<li><code>postorder.length == inorder.length</code></li>
<li><code>-3000 &lt;= inorder[i], postorder[i] &lt;= 3000</code></li>
<li><code>inorder</code> 和 <code>postorder</code> 都由 <strong>不同</strong> 的值组成</li>
<li><code>postorder</code> 中每一个值都在 <code>inorder</code> 中</li>
<li><code>inorder</code> <strong>保证</strong>是树的中序遍历</li>
<li><code>postorder</code> <strong>保证</strong>是树的后序遍历</li>
</ul>
<h4 id="思路-47"><a href="#思路-47" class="headerlink" title="思路"></a>思路</h4><p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240420233805356.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240420233805356.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240420233805356"></p>
<p>前序，中序，后序 之间除了</p>
<p><strong>前序和后序</strong>两个在一块，没法构造树，原因是</p>
<p>前序 中左右</p>
<p>后序 左右中</p>
<p>都能确定根节点，没有办法区分左和右</p>
<p><strong>中序，后序</strong> </p>
<p>中序 左中右</p>
<p>后序 左右中</p>
<ul>
<li>后序最后一个是中</li>
<li>在中序查找，分出来 左中侧部分和右中侧部分</li>
<li>在后序中根据长度去划分左后侧和右中侧部分</li>
<li>node.left &#x3D; fuc(左中侧部分，左后侧部分)</li>
<li>node.right &#x3D; fuc(右中侧部分，右后侧部分)</li>
</ul>
<h4 id="代码-45"><a href="#代码-45" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-38"><a href="#java代码-38" class="headerlink" title="java代码"></a>java代码</h5><h6 id="我的版本"><a href="#我的版本" class="headerlink" title="我的版本"></a>我的版本</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;</span><br><span class="line">        // 临界条件</span><br><span class="line">        // 后序为空，直接返回</span><br><span class="line">        if (postorder.length == 0) return null;</span><br><span class="line">        int val = postorder[postorder.length - 1];</span><br><span class="line">        // 分隔节点 后序最后一个</span><br><span class="line">        TreeNode node = new TreeNode(val);</span><br><span class="line">        if (postorder.length == 1) return node;</span><br><span class="line">        // 划分中序</span><br><span class="line">        // 这个是索引</span><br><span class="line">        int index =0;</span><br><span class="line">        for(;index&lt;inorder.length;index++)&#123;</span><br><span class="line">            if(inorder[index] == val) break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对中序进行分割</span><br><span class="line">        int[] leftin = new int[index];</span><br><span class="line">        // 左侧</span><br><span class="line">        for(int i=0;i&lt;index;i++) leftin[i] = inorder[i];</span><br><span class="line">        int[] rightin = new int[inorder.length - index - 1];</span><br><span class="line">        // 右侧</span><br><span class="line">        for(int i=index+1;i&lt;inorder.length;i++) rightin[i-index-1] = inorder[i];</span><br><span class="line">         </span><br><span class="line">        // 对后序进行分割</span><br><span class="line">        int[] leftpos = new int[index];</span><br><span class="line">        // 左侧</span><br><span class="line">        for(int i=0;i&lt;index;i++) leftpos[i] = postorder[i];</span><br><span class="line">        int[] rightpos = new int[inorder.length - index - 1];</span><br><span class="line">        // 右侧</span><br><span class="line">        for(int i=index;i&lt;postorder.length - 1;i++) rightpos[i-index] = postorder[i];</span><br><span class="line"></span><br><span class="line">        node.left = buildTree(leftin,leftpos);</span><br><span class="line">        node.right = buildTree(rightin,rightpos);</span><br><span class="line">        return node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="16、105-从前序与中序遍历序列构造二叉树-4-20"><a href="#16、105-从前序与中序遍历序列构造二叉树-4-20" class="headerlink" title="16、105. 从前序与中序遍历序列构造二叉树(4.20)"></a>16、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a>(4.20)</h3><p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt;= 3000</code></li>
<li><code>inorder.length == preorder.length</code></li>
<li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li>
<li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li>
<li><code>inorder</code> 均出现在 <code>preorder</code></li>
<li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li>
<li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li>
</ul>
<h4 id="代码-46"><a href="#代码-46" class="headerlink" title="代码"></a>代码</h4><p>java代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;</span><br><span class="line">        // 临界条件</span><br><span class="line">        if(preorder.length == 0) return null;</span><br><span class="line">        // 前序第一个值</span><br><span class="line">        int val = preorder[0];</span><br><span class="line">        TreeNode node = new TreeNode(val);</span><br><span class="line">        if(preorder.length == 1) return node;</span><br><span class="line"></span><br><span class="line">        // 分割</span><br><span class="line">        // 中的索引</span><br><span class="line">        int index = 0;</span><br><span class="line">        for(;index&lt;inorder.length;index++)&#123;</span><br><span class="line">            if(inorder[index] == val) break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 分割中序</span><br><span class="line">        int[] leftin = new int[index];</span><br><span class="line">        for(int i=0;i&lt;index;i++) leftin[i] = inorder[i];</span><br><span class="line">        int[] rightin = new int[inorder.length - index - 1];</span><br><span class="line">        for(int i=index + 1;i&lt;inorder.length;i++) rightin[i - index -1] = inorder[i];</span><br><span class="line"></span><br><span class="line">        // 分割前序</span><br><span class="line">        int[] leftpre = new int[index];</span><br><span class="line">        for(int i=1;i&lt;index+1;i++) leftpre[i-1] = preorder[i];</span><br><span class="line">        int[] rightpre = new int[inorder.length - index - 1];</span><br><span class="line">        for(int i=index + 1;i&lt;inorder.length;i++) rightpre[i - index -1] = preorder[i];</span><br><span class="line"></span><br><span class="line">        // 左右节点</span><br><span class="line">        node.left = buildTree(leftpre,leftin);</span><br><span class="line">        node.right = buildTree(rightpre,rightin);</span><br><span class="line"></span><br><span class="line">        return node;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="17、654-最大二叉树-4-21"><a href="#17、654-最大二叉树-4-21" class="headerlink" title="17、654. 最大二叉树(4.21)"></a>17、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a>(4.21)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p>
<ol>
<li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li>
<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1,6,0,5]</span><br><span class="line">输出：[6,3,5,null,2,0,null,null,1]</span><br><span class="line">解释：递归调用如下所示：</span><br><span class="line">- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。</span><br><span class="line">    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。</span><br><span class="line">        - 空数组，无子节点。</span><br><span class="line">        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。</span><br><span class="line">            - 空数组，无子节点。</span><br><span class="line">            - 只有一个元素，所以子节点是一个值为 1 的节点。</span><br><span class="line">    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。</span><br><span class="line">        - 只有一个元素，所以子节点是一个值为 0 的节点。</span><br><span class="line">        - 空数组，无子节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,1]</span><br><span class="line">输出：[3,null,2,null,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
</ul>
<h4 id="思路-48"><a href="#思路-48" class="headerlink" title="思路"></a>思路</h4><h5 id="一、分割数组，创建左右数组，比较麻烦"><a href="#一、分割数组，创建左右数组，比较麻烦" class="headerlink" title="一、分割数组，创建左右数组，比较麻烦"></a>一、分割数组，创建左右数组，比较麻烦</h5><p>就是找到最大的那个元素后，然后分割数组去传。</p>
<h5 id="二、分割数组-不创建左右数组，传索引去进行迭代，效果一样，但是更加简洁"><a href="#二、分割数组-不创建左右数组，传索引去进行迭代，效果一样，但是更加简洁" class="headerlink" title="二、分割数组,不创建左右数组，传索引去进行迭代，效果一样，但是更加简洁"></a>二、分割数组,不创建左右数组，传索引去进行迭代，效果一样，但是更加简洁</h5><h4 id="代码-47"><a href="#代码-47" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-39"><a href="#java代码-39" class="headerlink" title="java代码"></a>java代码</h5><h6 id="一、分割数组，比较麻烦"><a href="#一、分割数组，比较麻烦" class="headerlink" title="一、分割数组，比较麻烦"></a>一、分割数组，比较麻烦</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 最大值</span></span><br><span class="line">        <span class="type">int</span> maxNum=nums[<span class="number">0</span>],index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxNum)&#123;</span><br><span class="line">                maxNum = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(maxNum+<span class="string">&quot; ---- &quot;</span> + index);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxNum);</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> node;</span><br><span class="line">        <span class="comment">// left array</span></span><br><span class="line">        <span class="type">int</span>[] left_array = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;index;i++) left_array[i] = nums[i];</span><br><span class="line">        <span class="comment">// right array</span></span><br><span class="line">        <span class="type">int</span>[] right_array = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - index - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=index + <span class="number">1</span>;i&lt;nums.length;i++) right_array[i - index - <span class="number">1</span>] = nums[i];</span><br><span class="line"></span><br><span class="line">        node.left = constructMaximumBinaryTree(left_array);</span><br><span class="line">        node.right = constructMaximumBinaryTree(right_array);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="二、分割数组-不创建左右数组，传索引去进行迭代，效果一样，但是更加简洁-1"><a href="#二、分割数组-不创建左右数组，传索引去进行迭代，效果一样，但是更加简洁-1" class="headerlink" title="二、分割数组,不创建左右数组，传索引去进行迭代，效果一样，但是更加简洁"></a>二、分割数组,不创建左右数组，传索引去进行迭代，效果一样，但是更加简洁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.分割不创建数组。</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> construct(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">construct</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left,maxval = nums[left];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span>left + <span class="number">1</span>;i&lt;right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; maxval)&#123;</span><br><span class="line">                maxval = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxval);</span><br><span class="line">        <span class="comment">// 左侧</span></span><br><span class="line">        node.left = construct(nums,left,index);</span><br><span class="line">        node.right = construct(nums,index + <span class="number">1</span>,right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="18、617-合并二叉树-4-21"><a href="#18、617-合并二叉树-4-21" class="headerlink" title="18、617. 合并二叉树(4.21)"></a>18、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a>(4.21)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/merge.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/merge.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]</span><br><span class="line">输出：[3,4,5,5,4,null,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root1 = [1], root2 = [1,2]</span><br><span class="line">输出：[2,2]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两棵树中的节点数目在范围 <code>[0, 2000]</code> 内</li>
<li><code>-104 &lt;= Node.val &lt;= 104</code></li>
</ul>
<h4 id="思路-49"><a href="#思路-49" class="headerlink" title="思路"></a>思路</h4><h5 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a>我的思路</h5><p>分别考虑不同的情况，但是写起来有点复杂，都不为空，一个为空，全为空。</p>
<p><strong>思考的不完善！！</strong></p>
<p>没有仔细考虑清楚临界条件——到一个root1为null,节点直接就可以返回root2了，因此代码可以简化不少。</p>
<p>对于正常的处理代码就是root1和root2都不为空的情况，正常写即可</p>
<h4 id="代码-48"><a href="#代码-48" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-40"><a href="#java代码-40" class="headerlink" title="java代码"></a>java代码</h5><h6 id="我的思路-3"><a href="#我的思路-3" class="headerlink" title="我的思路"></a>我的思路</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line">        if(root1 == null &amp;&amp; root2 == null) return null;</span><br><span class="line">        int val = 0;</span><br><span class="line">        if(root1 != null) val += root1.val;</span><br><span class="line">        if(root2 != null) val += root2.val;</span><br><span class="line">        // node </span><br><span class="line">        TreeNode node = new TreeNode(val);</span><br><span class="line"></span><br><span class="line">        if (root1 == null &amp;&amp; root2 != null)&#123;</span><br><span class="line">            node.left = mergeTrees(null,root2.left);</span><br><span class="line">            node.right = mergeTrees(null,root2.right);</span><br><span class="line">        &#125;else if (root1 != null &amp;&amp; root2 == null)&#123;</span><br><span class="line">            node.left = mergeTrees(root1.left,null);</span><br><span class="line">            node.right = mergeTrees(root1.right,null);</span><br><span class="line">        &#125;else if (root1 != null &amp;&amp; root2 != null)&#123;</span><br><span class="line">            node.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">            node.right = mergeTrees(root1.right,root2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        return node;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="carl正常思路"><a href="#carl正常思路" class="headerlink" title="carl正常思路"></a>carl正常思路</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">null</span>) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(root2 == <span class="literal">null</span>) <span class="keyword">return</span> root1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常情况处理</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);</span><br><span class="line">        <span class="comment">// 左右</span></span><br><span class="line">        node.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        node.right = mergeTrees(root1.right,root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="19、700-二叉搜索树中的搜索-4-21"><a href="#19、700-二叉搜索树中的搜索-4-21" class="headerlink" title="19、700. 二叉搜索树中的搜索(4.21)"></a>19、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a>(4.21)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p>
<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>
<p><strong>示例 1:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 2</span><br><span class="line">输出：[2,1,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/01/12/tree2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数在 <code>[1, 5000]</code> 范围内</li>
<li><code>1 &lt;= Node.val &lt;= 107</code></li>
<li><code>root</code> 是二叉搜索树</li>
<li><code>1 &lt;= val &lt;= 107</code></li>
</ul>
<h4 id="思路-50"><a href="#思路-50" class="headerlink" title="思路"></a>思路</h4><p>思路类似二分查找，主要是什么时候是临界条件，</p>
<p>值相等或者节点是null直接返回root即可。</p>
<p>大于小于思路很直接。</p>
<h5 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h5><p>就是和上面思路一样，实现更加简单。</p>
<h4 id="代码-49"><a href="#代码-49" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-41"><a href="#java代码-41" class="headerlink" title="java代码"></a>java代码</h5><h6 id="1-递归法"><a href="#1-递归法" class="headerlink" title="1.递归法"></a>1.递归法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || val == root.val) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(val &lt; root.val) <span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="keyword">if</span>(val &gt; root.val) <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-迭代法"><a href="#2-迭代法" class="headerlink" title="2.迭代法"></a>2.迭代法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur.val &gt; val)&#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cur.val &lt; val)&#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><p>这里不要写成多个if,改变cur之后，仍然会进入下一个if，此时cur已经改变了，所以会报错，用if-else保证只进一个代码中</p>
<h3 id="20、98-验证二叉搜索树-4-21"><a href="#20、98-验证二叉搜索树-4-21" class="headerlink" title="20、98. 验证二叉搜索树(4.21)"></a>20、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a>(4.21)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li><p>节点的左</p>
<p>子树</p>
<p>只包含</p>
<p> 小于 </p>
<p>当前节点的数。</p>
</li>
<li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p>
</li>
<li><p>所有左子树和右子树自身必须也是二叉搜索树。</p>
</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目范围在<code>[1, 104]</code> 内</li>
<li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li>
</ul>
<h4 id="思路-51"><a href="#思路-51" class="headerlink" title="思路"></a>思路</h4><h5 id="一、递归方法"><a href="#一、递归方法" class="headerlink" title="一、递归方法"></a>一、递归方法</h5><p>根据二叉搜索树的特性，中序遍历是一个有序数组，按题意来说，就是升序数组。</p>
<p><strong>思考:</strong></p>
<p>不能单纯的比较<strong>左节点小于中间节点，右节点大于中间节点</strong>就完事了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (root-&gt;val &gt; root-&gt;left-&gt;val &amp;&amp; root-&gt;val &lt; root-&gt;right-&gt;val) &#123;</span><br><span class="line">	return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">	return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要⽐较的是 <strong>左⼦树所有节点⼩于中间节点，右⼦树所有节点⼤于中间节点</strong>。</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240421214917273.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240421214917273.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240421214917273"></p>
<p>陷阱2<br>样例中最小节点可能是int的最小值，如果这样使用最小的int来比较也是不行的。此时可以初始化比较元素为longlong的最小值。<br>问题可以进一步演进∶<strong>如果样例中根节点的val 可能是longlong的最小值又要怎么办呢</strong>?</p>
<p>如果测试数据中有longlong的最小值，怎么办?<br>不可能在初始化一个更小的值了吧。建议避免初始化最小值，如下方法取到<strong>最左面节点的数值来比较</strong>。</p>
<h5 id="二、carl设置最小值的递归方法"><a href="#二、carl设置最小值的递归方法" class="headerlink" title="二、carl设置最小值的递归方法"></a>二、carl设置最小值的递归方法</h5><p>递归三部曲：</p>
<ul>
<li>确定递归函数，返回值以及参数</li>
</ul>
<p>要定义一个longlong的全局变量，用来比较遍历的节点是否有序，因为后台的测试数据中有int最小值，所以定义为longlong的类型，初始化为longlong的最小值。</p>
<p><strong>返回值：</strong>只有寻找某一条边（或者节点）的时候，递归函数会有bool类型的返回值。</p>
<p>本题是在寻找一个不符合条件的节点，如果没有找到这个节点就遍历了整棵树，如果找不到符合节点，就离开返回。</p>
<p>C++代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long long maxVal = LONG_MIN;//后台测试数据有int最小值</span><br></pre></td></tr></table></figure>

<p>比较</p>
<p>maxVal是代表前一个元素，root是当前元素，从左到右递增。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(root.val &gt; maxVal)&#123;</span><br><span class="line">      maxVal = root.val;</span><br><span class="line">&#125;else&#123; return false;&#125;</span><br></pre></td></tr></table></figure>

<p>不使用值，使用前后节点，使用双指针进行比较</p>
<p>比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(pre != null &amp;&amp; root.val &lt;= pre.val)&#123;</span><br><span class="line">          return false;</span><br><span class="line">&#125;</span><br><span class="line">// 始终指向前一个元素</span><br><span class="line">pre = root;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="代码-50"><a href="#代码-50" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-42"><a href="#java代码-42" class="headerlink" title="java代码"></a>java代码</h5><h6 id="1-我的中序遍历"><a href="#1-我的中序遍历" class="headerlink" title="1.我的中序遍历"></a>1.我的中序遍历</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        midSearch(root,li);</span><br><span class="line">        <span class="comment">// 要减去1，是因为要相邻的比</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;li.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(li.get(i) &gt;= li.get(i+<span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midSearch</span><span class="params">(TreeNode root,List&lt;Integer&gt; li)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        midSearch(root.left,li);</span><br><span class="line">        li.add(root.val);</span><br><span class="line">        midSearch(root.right,li);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-二叉搜索树的特性"><a href="#2-二叉搜索树的特性" class="headerlink" title="2.二叉搜索树的特性"></a>2.二叉搜索树的特性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">      <span class="comment">// 临界条件</span></span><br><span class="line">      <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 中序</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST(root.left);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(pre != <span class="literal">null</span> &amp;&amp; root.val &lt;= pre.val)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//记录前一个</span></span><br><span class="line">      pre = root;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> isValidBST(root.right);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="21、530-二叉搜索树的最小绝对差-4-22"><a href="#21、530-二叉搜索树的最小绝对差-4-22" class="headerlink" title="21、530. 二叉搜索树的最小绝对差(4.22)"></a>21、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a>(4.22)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/bst1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/bst1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目范围是 <code>[2, 104]</code></li>
<li><code>0 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p><strong>注意：</strong>本题与 783 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</p>
<h4 id="思路-52"><a href="#思路-52" class="headerlink" title="思路"></a>思路</h4><p>中序遍历，使用前后指针来计算差值的绝对值和最小值不断更新最小值即可。</p>
<p>一种是使用最小值充当返回值，另一种是不用返回值，去遍历二叉树即可</p>
<h4 id="代码-51"><a href="#代码-51" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-43"><a href="#java代码-43" class="headerlink" title="java代码"></a>java代码</h5><h6 id="1-使用最小值充当返回值"><a href="#1-使用最小值充当返回值" class="headerlink" title="1.使用最小值充当返回值"></a>1.使用最小值充当返回值</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode pre =  null;</span><br><span class="line">    int val = Integer.MAX_VALUE;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">        if(root.left != null) getMinimumDifference(root.left);</span><br><span class="line">        if(pre != null )&#123;</span><br><span class="line">             val = Math.min(Math.abs(root.val - pre.val),val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        if(root.right != null) getMinimumDifference(root.right);</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="2-不用返回值，去遍历二叉树"><a href="#2-不用返回值，去遍历二叉树" class="headerlink" title="2.不用返回值，去遍历二叉树"></a>2.不用返回值，去遍历二叉树</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode pre =  null;</span><br><span class="line">    int val = Integer.MAX_VALUE;</span><br><span class="line">    public int getMinimumDifference(TreeNode root) &#123;</span><br><span class="line">        getMi(root);</span><br><span class="line">        return val;</span><br><span class="line">    &#125;</span><br><span class="line">    //遍历搜索树</span><br><span class="line">    public void getMi(TreeNode root) &#123;</span><br><span class="line">        if (root == null) return ;</span><br><span class="line">        getMi(root.left);</span><br><span class="line">        if(pre != null )&#123;</span><br><span class="line">             val = Math.min(Math.abs(root.val - pre.val),val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        getMi(root.right);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="22、783-二叉搜索树节点最小距离-4-22-和上一个一样"><a href="#22、783-二叉搜索树节点最小距离-4-22-和上一个一样" class="headerlink" title="22、783. 二叉搜索树节点最小距离(4.22) 和上一个一样"></a>22、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a>(4.22) 和上一个一样</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/bst2.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/bst2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目范围是 <code>[2, 100]</code></li>
<li><code>0 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p><strong>注意：</strong>本题与 530：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/</a> 相同</p>
<h4 id="代码-52"><a href="#代码-52" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span>  <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        getMi(root);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历搜索树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMi</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        getMi(root.left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">null</span> )&#123;</span><br><span class="line">             val = Math.min(Math.abs(root.val - pre.val),val);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        getMi(root.right);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="23、501-二叉搜索树中的众数-4-22"><a href="#23、501-二叉搜索树中的众数-4-22" class="headerlink" title="23、501. 二叉搜索树中的众数(4.22)"></a>23、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a>(4.22)</h3><p>已解答</p>
<p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>
<p>假定 BST 满足如下定义：</p>
<ul>
<li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li>
<li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/mode-tree.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/mode-tree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,null,2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<h4 id="思路-53"><a href="#思路-53" class="headerlink" title="思路"></a>思路</h4><h5 id="1-普通二叉树思路-代码有点复杂，思想不难，写起来有点复杂"><a href="#1-普通二叉树思路-代码有点复杂，思想不难，写起来有点复杂" class="headerlink" title="1.普通二叉树思路(代码有点复杂，思想不难，写起来有点复杂)"></a>1.普通二叉树思路(代码有点复杂，思想不难，写起来有点复杂)</h5><p>如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。</p>
<h5 id="2-二叉搜索树的思路"><a href="#2-二叉搜索树的思路" class="headerlink" title="2.二叉搜索树的思路"></a>2.二叉搜索树的思路</h5><p>​	遍历有序数组的元素出现频率，从头遍历，那么一定是相邻两个元素作比较，然后就把出现频率最高的元素输出就可以了。<br>关键是在有序数组上的话，好搞，在树上怎么搞呢?这就考察对树的操作了。<br>​	在二叉树:搜索树的最小绝对差中我们就使用了pre指针和cur指针的技巧，这次又用上了。弄一个指针指向前一个节点，这样每次cur(当前节点)才能和pre(前一个节点)作比较。而且初始化的时候pre &#x3D; NULL，这样当pre为NULL时候，我们就知道这是比较的第一个元素。</p>
<h4 id="代码-53"><a href="#代码-53" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-44"><a href="#java代码-44" class="headerlink" title="java代码"></a>java代码</h5><h6 id="1-普通二叉树思路"><a href="#1-普通二叉树思路" class="headerlink" title="1.普通二叉树思路"></a>1.普通二叉树思路</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">	public int[] findMode(TreeNode root) &#123;</span><br><span class="line">		Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">		List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">		if (root == null) return list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">		// 获得频率 Map</span><br><span class="line">		searchBST(root, map);</span><br><span class="line">		List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()</span><br><span class="line">				.sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		list.add(mapList.get(0).getKey());</span><br><span class="line">		// 把频率最高的加入 list  实际上就是和mapList的第一个一样高的频率的元素加入list。</span><br><span class="line">		for (int i = 1; i &lt; mapList.size(); i++) &#123;</span><br><span class="line">			if (mapList.get(i).getValue() == mapList.get(i - 1).getValue()) &#123;</span><br><span class="line">				list.add(mapList.get(i).getKey());</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	void searchBST(TreeNode curr, Map&lt;Integer, Integer&gt; map) &#123;</span><br><span class="line">		if (curr == null) return;</span><br><span class="line">		map.put(curr.val, map.getOrDefault(curr.val, 0) + 1);</span><br><span class="line">		searchBST(curr.left, map);</span><br><span class="line">		searchBST(curr.right, map);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (root == null) return list.stream().mapToInt(Integer::intValue).toArray();</span><br></pre></td></tr></table></figure>

<ul>
<li>将存储频率最高节点值的ArrayList转换为IntStream（<code>list.stream()</code>）。</li>
<li>使用<code>mapToInt</code>方法将Integer类型的流转换为IntStream，以便后续调用<code>toArray</code>方法转换为int数组。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()</span><br><span class="line">				.sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))</span><br><span class="line">				.collect(Collectors.toList());</span><br><span class="line">		list.add(mapList.get(0).getKey());</span><br></pre></td></tr></table></figure>

<ul>
<li>将HashMap的entrySet转换为流，并通过<code>sorted</code>方法对entrySet进行排序。排序使用了一个Lambda表达式，比较器的逻辑是按照entry的值（即节点值的频率）降序排列，即先比较频率，频率高的排在前面。</li>
<li><strong>收集排序后的结果：</strong>使用<code>collect</code>方法将排序后的entrySet收集到一个List中。这样就得到了按照频率降序排列的entry列表（<code>mapList</code>）。</li>
<li><strong>添加频率最高的节点值：</strong><ul>
<li>将排序后的entry列表中第一个entry（即频率最高的节点值）的键（即节点值）添加到存储结果的ArrayList中（<code>list</code>）。</li>
<li>通过<code>mapList.get(0).getKey()</code>获取第一个entry，并调用<code>getKey</code>方法获取其键（即节点值），然后将其添加到<code>list</code>中。</li>
</ul>
</li>
</ul>
<h6 id="2-二叉搜索树的思路-1"><a href="#2-二叉搜索树的思路-1" class="headerlink" title="2.二叉搜索树的思路"></a>2.二叉搜索树的思路</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.二叉搜索树的特性思路</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>,count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// 返回值</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        findM(root ,res);</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[res.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;res.size();i++)&#123;</span><br><span class="line">            result[i] = res.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 中序遍历二叉树即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span>  <span class="title function_">findM</span><span class="params">(TreeNode node,List&lt;Integer&gt; res )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 左</span></span><br><span class="line">        findM(node.left,res);</span><br><span class="line">        <span class="comment">// 中</span></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">null</span>)&#123;</span><br><span class="line">            count = <span class="number">1</span>; <span class="comment">//此时node一定不为空。</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre.val == node.val)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//计数node的方法</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等于最大频率，记录元素</span></span><br><span class="line">        <span class="keyword">if</span>(count == maxCount) &#123;</span><br><span class="line">            res.add(node.val);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count &gt; maxCount)&#123; <span class="comment">//保持是最高频率的元素。</span></span><br><span class="line">            <span class="comment">// 清空再加入</span></span><br><span class="line">            res.clear();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            maxCount = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录前一个值</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右侧</span></span><br><span class="line">        findM(node.right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="24、236-二叉树的最近公共祖先-4-23"><a href="#24、236-二叉树的最近公共祖先-4-23" class="headerlink" title="24、236. 二叉树的最近公共祖先(4.23)"></a>24、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a>(4.23)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/binarytree.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/binarytree.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/binarytree.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/binarytree.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[2, 105]</code> 内。</li>
<li><code>-109 &lt;= Node.val &lt;= 109</code></li>
<li><strong>所有 <code>Node.val</code> <code>互不相同</code></strong> 。</li>
<li><code>p != q</code></li>
<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>
</ul>
<h4 id="思路-54"><a href="#思路-54" class="headerlink" title="思路"></a>思路</h4><h5 id="临界条件"><a href="#临界条件" class="headerlink" title="临界条件"></a>临界条件</h5><p>遇到空的话，因为树都是空了，所以返回空<br>那么我们来说一说，如果 root&#x3D;&#x3D; q，或者 root&#x3D;&#x3D;p，说明找到 qp，则将其返回，这个返回值，后面在中节点的处理过程中会用到，那么中节点的处理逻辑，下面讲解。</p>
<h5 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h5><p>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解<br>如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然这里有的同学就理解不了了，为什么left为空，right不为空，目标节点通过right返回呢?</p>
<p>因为right子树中一定包含p,q之一，或者都有，所以可以直接返回，有一个往上返回，和另一个一定会在某一个root的left和right相遇；或者已经有p,q了，也就是最近公共祖先了，直接返回。</p>
<h4 id="代码-54"><a href="#代码-54" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-45"><a href="#java代码-45" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">// 只要返回不为空就表示这个节点存在，因为P,Q不一样，只出现一次</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == p.val || root.val == q.val ) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常情况,通过后序向上返回，判断左右节点有没有出现过</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right,p,q);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断逻辑</span></span><br><span class="line">        <span class="comment">// 说明p,q都没有出现过</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 有一个不为空，就返回不为空的那个</span></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">null</span> &amp;&amp; right==<span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="comment">// 都不为空说明就是公共祖先，一定是最近的共同祖先首先进入if，所以返回root就好</span></span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">null</span> &amp;&amp; right!=<span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25、235-二叉搜索树的最近公共祖先-4-24"><a href="#25、235-二叉搜索树的最近公共祖先-4-24" class="headerlink" title="25、235. 二叉搜索树的最近公共祖先(4.24)"></a>25、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a>(4.24)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root &#x3D; [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/binarysearchtree_improved.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/binarysearchtree_improved.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<h4 id="代码-55"><a href="#代码-55" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-46"><a href="#java代码-46" class="headerlink" title="java代码"></a>java代码</h5><h6 id="我的代码-5"><a href="#我的代码-5" class="headerlink" title="我的代码"></a>我的代码</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        // 临界条件</span><br><span class="line">        if(p.val &gt; q.val)&#123;</span><br><span class="line">            TreeNode tmp = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(root == null || root.val &gt;= p.val &amp;&amp; root.val &lt;= q.val ) return root;</span><br><span class="line"></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        if(left!=null) &#123;</span><br><span class="line">            return left;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return right;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="更精简的代码"><a href="#更精简的代码" class="headerlink" title="更精简的代码"></a>更精简的代码</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 2.更精简的代码</span><br><span class="line">public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line"></span><br><span class="line">    // 临界条件</span><br><span class="line">    // 如果小于p,q的值进入right,大于进left</span><br><span class="line">    if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val )&#123;</span><br><span class="line">        return lowestCommonAncestor(root.left,p,q);</span><br><span class="line">    &#125;else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val )&#123;</span><br><span class="line">        return lowestCommonAncestor(root.right,p,q);</span><br><span class="line">    &#125;else return root;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="26、701-二叉搜索树中的插入操作-4-24"><a href="#26、701-二叉搜索树中的插入操作-4-24" class="headerlink" title="26、701. 二叉搜索树中的插入操作(4.24)"></a>26、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a>(4.24)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/insertbst.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/insertbst.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数将在 <code>[0, 104]</code>的范围内。</li>
<li><code>-108 &lt;= Node.val &lt;= 108</code></li>
<li>所有值 <code>Node.val</code> 是 <strong>独一无二</strong> 的。</li>
<li><code>-108 &lt;= val &lt;= 108</code></li>
<li><strong>保证</strong> <code>val</code> 在原始BST中不存在。</li>
</ul>
<h4 id="思路-55"><a href="#思路-55" class="headerlink" title="思路"></a>思路</h4><p>思路就是根据二叉搜索树的特性，root.val&gt;val，说明应该向左侧遍历，反之右侧，当遇到null的时候说明到位置了，</p>
<p>创建节点即可。</p>
<h4 id="代码-56"><a href="#代码-56" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-47"><a href="#java代码-47" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">vnode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">        node = vnode;</span><br><span class="line">        insert(root,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="comment">// 正常逻辑</span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; val)&#123;</span><br><span class="line">             <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)&#123; </span><br><span class="line">                insertIntoBST(root.left, val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">                root.left = node;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; val  )&#123;</span><br><span class="line">            <span class="keyword">if</span>( root.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                insertIntoBST(root.right, val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root.right = node;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更简洁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更加简洁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="comment">// 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val); <span class="comment">// 递归创建右子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val); <span class="comment">// 递归创建左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="27、450-删除二叉搜索树中的节点-4-25"><a href="#27、450-删除二叉搜索树中的节点-4-25" class="headerlink" title="27、450. 删除二叉搜索树中的节点(4.25)"></a>27、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a>(4.25)</h3><p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ol>
<p><strong>示例 1:</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/del_node_1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/del_node_1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br><span class="line">解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。</span><br><span class="line">一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。</span><br><span class="line">另一个正确答案是 [5,2,6,null,4,null,7]。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,3,6,2,4,null,7], key = 0</span><br><span class="line">输出: [5,3,6,2,4,null,7]</span><br><span class="line">解释: 二叉树不包含值为 0 的节点</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [], key = 0</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li>节点数的范围 <code>[0, 104]</code>.</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li>节点值唯一</li>
<li><code>root</code> 是合法的二叉搜索树</li>
<li><code>-105 &lt;= key &lt;= 105</code></li>
</ul>
<p><strong>进阶：</strong> 要求算法时间复杂度为 O(h)，h 为树的高度。</p>
<h4 id="思路-56"><a href="#思路-56" class="headerlink" title="思路"></a>思路</h4><p>五种情况太多，</p>
<ul>
<li><p>没找到（遍历到null时），直接返回null</p>
</li>
<li><p>叶子节点，直接返回null即可</p>
</li>
<li><p>左孩子不为空，右孩子为空，返回root.left就可以，正常的逻辑要接收这个。</p>
</li>
<li><p>右孩子不为空，左孩子为空，返回root.right就可以，正常的逻辑要接收这个。</p>
</li>
<li><p>左右都不为空，删7的话，需要找到比7稍大的就是root的右孩子的一路左孩子的root.left为空的节点，替换为root.left，然后返回root.right（因为左侧已经没了，删除root节点，返回root.right就行）</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240427220550050.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240427220550050.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240427220550050"></p>
</li>
</ul>
<p>通过返回值来删除节点也比较复杂，尤其是左右孩子都不为空，需要调整二叉搜索树的结构。</p>
<h4 id="代码-57"><a href="#代码-57" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-48"><a href="#java代码-48" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="comment">// 没找到节点,正常逻辑不会走到null的</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 找到了</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == key)&#123;</span><br><span class="line">            <span class="comment">// 叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 左孩子不为空，右孩子为空</span></span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">// 右孩子不为空，左孩子为空</span></span><br><span class="line">            <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>)&#123;<span class="comment">// 左右都不为空</span></span><br><span class="line">                <span class="comment">// 找到右孩子的一路向左的root.left==null的节点，替换现在的root.left</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span>(cur.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据bst特性，正常处理逻辑</span></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; key)&#123;</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="28、669-修剪二叉搜索树-4-26"><a href="#28、669-修剪二叉搜索树-4-26" class="headerlink" title="28、669. 修剪二叉搜索树(4.26)"></a>28、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a>(4.26)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/trim1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/trim1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,2], low = 1, high = 2</span><br><span class="line">输出：[1,null,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/trim2.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/trim2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</span><br><span class="line">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中节点数在范围 <code>[1, 104]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 104</code></li>
<li>树中每个节点的值都是 <strong>唯一</strong> 的</li>
<li>题目数据保证输入是一棵有效的二叉搜索树</li>
<li><code>0 &lt;= low &lt;= high &lt;= 104</code></li>
</ul>
<h4 id="思路-57"><a href="#思路-57" class="headerlink" title="思路"></a>思路</h4><p>当前节点小于范围，但是右子树有可能满足条件，所以需要调用函数进行删减右侧的树，然后返回这个即可。</p>
<p>反之，当前节点大于范围，但是左子树有可能满足条件，所以需要调用函数进行删减左侧的树，然后返回这个即可。</p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240427223442186.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/image-20240427223442186.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20240427223442186"></p>
<h4 id="代码-58"><a href="#代码-58" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-49"><a href="#java代码-49" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> ) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low)&#123;</span><br><span class="line">            <span class="comment">// 测试右节点，顺便删掉这个root</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right,low,high);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; high)&#123;</span><br><span class="line">            <span class="comment">// 测试左节点，顺便删掉这个root</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left,low,high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常处理</span></span><br><span class="line">        root.left = trimBST(root.left,low,high);</span><br><span class="line">        root.right = trimBST(root.right,low,high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码不长，思考很难。</p>
<h3 id="29、108-将有序数组转换为二叉搜索树-4-27"><a href="#29、108-将有序数组转换为二叉搜索树-4-27" class="headerlink" title="29、108. 将有序数组转换为二叉搜索树(4.27)"></a>29、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a>(4.27)</h3><p>简单</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 </p>
<p>平衡</p>
<p> 二叉搜索树。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/btree1.jpg" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/btree1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" class="lazyload" data-srcset="https://assets.leetcode.com/uploads/2021/02/18/btree.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>
</ul>
<h4 id="思路-58"><a href="#思路-58" class="headerlink" title="思路"></a>思路</h4><p>取中间的节点，如果是偶数，只要左右选择的</p>
<p>索引节点一样，仍然是平衡二叉树</p>
<h4 id="代码-59"><a href="#代码-59" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-50"><a href="#java代码-50" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        <span class="keyword">return</span> sorBST(nums,<span class="number">0</span>,nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左闭右开</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sorBST</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        node.left = sorBST(nums,left,mid);</span><br><span class="line">        node.right = sorBST(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="30、538-把二叉搜索树转换为累加树-4-27"><a href="#30、538-把二叉搜索树转换为累加树-4-27" class="headerlink" title="30、538. 把二叉搜索树转换为累加树(4.27)"></a>30、<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a>(4.27)</h3><p>已解答</p>
<p>中等</p>
<p>相关标签</p>
<p>相关企业</p>
<p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>注意：</strong>本题和 1038: <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/tree.png" class="lazyload" data-srcset="https://gitee.com/zhang-junjie123/picture/raw/master/image/tree.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class="line">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0,null,1]</span><br><span class="line">输出：[1,null,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,2]</span><br><span class="line">输出：[3,3,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,2,4,1]</span><br><span class="line">输出：[7,9,4,10] </span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li>
<li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li>
<li>树中的所有值 <strong>互不相同</strong> 。</li>
<li>给定的树为二叉搜索树。</li>
</ul>
<h4 id="思路-59"><a href="#思路-59" class="headerlink" title="思路"></a>思路</h4><p>右中左，保存前一个节点的值，全局变量保存。</p>
<h4 id="代码-60"><a href="#代码-60" class="headerlink" title="代码"></a>代码</h4><h5 id="java代码-51"><a href="#java代码-51" class="headerlink" title="java代码"></a>java代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        convert(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">convert</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 临界条件</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// 右侧</span></span><br><span class="line">        convert(root.right);</span><br><span class="line">        root.val += pre;</span><br><span class="line">        pre = root.val;</span><br><span class="line">        convert(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2024-10-17T21:21:08+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：Oct 17, 2024</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%88%B7%E9%A2%98/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>刷题</p></a></div>
  <span hidden itemprop="keywords">刷题</span>


        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://example.com/2024/10/17/leetcode%E5%88%B7%E9%A2%98/&title=leetcode刷题(1) - 圣者纯洁&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://example.com/2024/10/17/leetcode%E5%88%B7%E9%A2%98/&title=leetcode刷题(1) - 圣者纯洁&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://example.com/2024/10/17/leetcode%E5%88%B7%E9%A2%98/&title=leetcode刷题(1) - 圣者纯洁&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
    
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/2024/11/02/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>A Survey of Resource-efficient LLM and Multimodal Foundation Models</p>
          <p class='content'>11.02 A Survey of Resource-efficient LLM and Multimodal Foundation ModelsAbstractLarge foundation...</p>
        </a>
      
      
        <a class='next' href='/2024/10/13/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/'>
          <p class='title'>我的第一篇文章<i class="fa-solid fa-chevron-right" aria-hidden="true"></i></p>
          <p class='content'>你好，我是张俊杰，很高兴看到你！
临时测试
数据库中有三个表如下：用户表：users（user_id, advertisement_id, date, sex）广告展示表：advertiseme...</p>
        </a>
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  


  <article class="post white-box shadow floatable blur" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/2024/10/17/leetcode%E5%88%B7%E9%A2%98/index.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    

    <div id="layoutHelper-comments"></div>

  </article>






</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop mobile " id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%8153-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="toc-text">1、53. 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-text">贪心算法思想：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-text">动态规划思想：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-3-23"><span class="toc-text">2、704. 二分查找 (3.23)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">我的代码：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Python-%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD%E5%86%99%E6%B3%95"><span class="toc-text">Python   左闭右闭写法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E7%89%88%E6%9C%AC"><span class="toc-text">java版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E3%80%8127-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-3-23"><span class="toc-text">3 、27. 移除元素 (3.23)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95"><span class="toc-text">双指针法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-text">双指针优化版本</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-text">算法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-text">我的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-%E5%8F%8C%E6%8C%87%E9%92%88%E6%99%AE%E9%80%9A%E7%89%88%E6%9C%AC"><span class="toc-text">python代码  双指针普通版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96%E7%89%88%E6%9C%AC"><span class="toc-text">java代码   双指针优化版本</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-3-24"><span class="toc-text">4、977. 有序数组的平方(3.24)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81-1"><span class="toc-text">我的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python"><span class="toc-text">python</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java"><span class="toc-text">java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-3-24"><span class="toc-text">5、209. 长度最小的子数组(3.24)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-text">我的思考</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81-2"><span class="toc-text">我的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python-1"><span class="toc-text">python</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java-1"><span class="toc-text">java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%8159-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-II-3-24"><span class="toc-text">6、59. 螺旋矩阵 II (3.24)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81-3"><span class="toc-text">我的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java-2"><span class="toc-text">java</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E8%A7%A3%E6%B3%95-%E4%B8%A4%E7%A7%8D%E4%B8%8D%E7%9F%A5%E9%81%93%E7%BB%93%E6%9E%9C%E4%B8%BA%E5%95%A5%E4%B8%8D%E5%AF%B9%EF%BC%8C%E5%BE%88%E5%A5%87%E6%80%AA%E3%80%82"><span class="toc-text">python解法  两种不知道结果为啥不对，很奇怪。</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">链表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-3-25"><span class="toc-text">1、203. 移除链表元素(3.25)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81"><span class="toc-text">python代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81"><span class="toc-text">java代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8-3-25-3-29"><span class="toc-text">2、707. 设计链表(3.25,3.29)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-1"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-1"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-3-25"><span class="toc-text">3、206. 反转链表(3.25)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-2"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-2"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%8124-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-3-28"><span class="toc-text">4、24. 两两交换链表中的节点(3.28)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81-4"><span class="toc-text">我的代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-3"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-3"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%8119-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9-3-28"><span class="toc-text">5、19. 删除链表的倒数第 N 个结点(3.28)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-4"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-4"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II-3-29"><span class="toc-text">6、142. 环形链表 II(3.29)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-text">我的思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-5"><span class="toc-text">python代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-5"><span class="toc-text">java代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%A2%B0%E6%92%9E"><span class="toc-text">哈希碰撞</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%89%E9%93%BE%E6%B3%95"><span class="toc-text">拉链法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-3-29"><span class="toc-text">1、242. 有效的字母异位词(3.29)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-8"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-6"><span class="toc-text">python代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-6"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-3-30"><span class="toc-text">2、349. 两个数组的交集(3.30)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-9"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-7"><span class="toc-text">python代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-7"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%811-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-3-30"><span class="toc-text">3、1. 两数之和(3.30)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-10"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-8"><span class="toc-text">python代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-8"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II-3-30"><span class="toc-text">4、454. 四数相加 II(3.30)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-11"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-8"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-9"><span class="toc-text">python代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-9"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%8115-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-3-31"><span class="toc-text">5、15. 三数之和(3.31)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-12"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="toc-text">哈希表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%8A%A0%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-text">排序加双指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%BB%E9%87%8D%E9%80%BB%E8%BE%91"><span class="toc-text">去重逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#a%E7%9A%84%E5%8E%BB%E9%87%8D"><span class="toc-text">a的去重</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#b%E4%B8%8Ec%E7%9A%84%E5%8E%BB%E9%87%8D"><span class="toc-text">b与c的去重</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-9"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-10"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-10"><span class="toc-text">python代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BD%BF%E7%94%A8%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">python使用哈希表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%8118-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-3-31"><span class="toc-text">6、18. 四数之和 (3.31)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-13"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%8A%A0%E5%8F%8C%E6%8C%87%E9%92%88-1"><span class="toc-text">排序加双指针</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-10"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-11"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-11"><span class="toc-text">python代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">python哈希表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-4-2"><span class="toc-text">1、344. 反转字符串 (4.2)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-14"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-11"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-II-4-3"><span class="toc-text">2、541. 反转字符串 II(4.3)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-15"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-12"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-12"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-12"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D-4-3"><span class="toc-text">3、151. 反转字符串中的单词(4.3)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-16"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-13"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-13"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-13"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%8128-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87-4-4"><span class="toc-text">4、28. 找出字符串中第一个匹配项的下标(4.4)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-17"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-14"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-14"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-14"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81LCR-122-%E8%B7%AF%E5%BE%84%E5%8A%A0%E5%AF%86-4-4"><span class="toc-text">5、LCR 122. 路径加密(4.4)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-18"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-15"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E4%BB%A3%E7%A0%81"><span class="toc-text">C++代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-15"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81LCR-182-%E5%8A%A8%E6%80%81%E5%8F%A3%E4%BB%A4-4-4"><span class="toc-text">6、LCR 182. 动态口令(4.4)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-19"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-16"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-16"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-15"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-4-5"><span class="toc-text">7、459. 重复的子字符串(4.5)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-20"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-17"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-17"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-16"><span class="toc-text">python代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%EF%BC%884-5%EF%BC%89"><span class="toc-text">1、232. 用栈实现队列（4.5）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-21"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-18"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-18"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-17"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88%EF%BC%884-5%EF%BC%89"><span class="toc-text">2、225. 用队列实现栈（4.5）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-22"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-19"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-19"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-18"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%8120-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-4-6"><span class="toc-text">3、20. 有效的括号(4.6)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-23"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-20"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-20"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-19"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%811047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9-4-7"><span class="toc-text">4、1047. 删除字符串中的所有相邻重复项(4.7)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-24"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-21"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-21"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-20"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC-4-8"><span class="toc-text">5、150. 逆波兰表达式求值(4.8)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-25"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-22"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-22"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-21"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-4-9"><span class="toc-text">6、239. 滑动窗口最大值(4.9)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-26"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-23"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-23"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-22"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-4-10"><span class="toc-text">7、347. 前 K 个高频元素(4.10)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-27"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-24"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-24"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-23"><span class="toc-text">python代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80"><span class="toc-text">0、二叉树基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-text">二叉树的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">平衡二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">二叉树的存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">二叉树的遍历方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9A%E4%B9%89"><span class="toc-text">二叉树定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-4-11"><span class="toc-text">1、二叉树前中后序递归遍历(4.11)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-4-11"><span class="toc-text">(1)144. 二叉树的前序遍历(4.11)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-28"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-25"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-4-11"><span class="toc-text">(2)94. 二叉树的中序遍历(4.11)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-29"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-26"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-4-11"><span class="toc-text">(3)145. 二叉树的后序遍历(4.11)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-30"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-27"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%EF%BC%89-4-12"><span class="toc-text">2. 二叉树的迭代遍历（非递归遍历）(4.12)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E9%80%92%E5%BD%92%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="toc-text">为什么非递归可以？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-4-12"><span class="toc-text">(1)144. 二叉树的前序遍历(4.12)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-text">前序遍历非递归的思路：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-28"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-4-12"><span class="toc-text">(2)94. 二叉树的中序遍历(4.12)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-31"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-29"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-4-12"><span class="toc-text">(3)145. 二叉树的后序遍历(4.12)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-32"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-30"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">3、二叉树层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-4-13"><span class="toc-text">(1)102. 二叉树的层序遍历(4.13)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-33"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-31"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-II-4-14"><span class="toc-text">(2)107. 二叉树的层序遍历 II(4.14)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-34"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-32"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE-4-14"><span class="toc-text">(3)199. 二叉树的右视图(4.14)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-35"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-33"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-4-14"><span class="toc-text">4、226. 翻转二叉树(4.14)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-36"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-34"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-4-16"><span class="toc-text">java代码(4.16)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-27"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-4-15"><span class="toc-text">5、101. 对称二叉树(4.15)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-37"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-35"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-28"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-28"><span class="toc-text">python代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9Apython%E4%B8%8D%E8%A6%81%E5%86%8D%E5%86%99-None-%E7%94%A8is-None"><span class="toc-text">注意：python不要再写 &#x3D;&#x3D; None,用is None</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%81%B5%E7%A5%9E%E5%86%99%E6%B3%95"><span class="toc-text">灵神写法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-4-16"><span class="toc-text">6、104. 二叉树的最大深度(4.16)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-38"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-36"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-29"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-29"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-4-16"><span class="toc-text">7、111. 二叉树的最小深度(4.16)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-39"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">前序遍历???</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-37"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-30"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-30"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-4-16"><span class="toc-text">8、222. 完全二叉树的节点个数(4.16)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-40"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-38"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-31"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-31"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-4-16"><span class="toc-text">9、110. 平衡二叉树(4.16)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-41"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-39"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-32"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-32"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-4-17"><span class="toc-text">10、257. 二叉树的所有路径(4.17)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-42"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E4%B8%89%E9%83%A8%E6%9B%B2"><span class="toc-text">递归三部曲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">单个处理逻辑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-40"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-33"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-33"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C-4-18"><span class="toc-text">11、404. 左叶子之和(4.18)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-43"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%BF%99%E9%87%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%89%8D%E5%BA%8F%E3%80%82"><span class="toc-text">递归这里相当于前序。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84"><span class="toc-text">不用返回值的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84"><span class="toc-text">需要返回值的</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95%E2%80%94%E2%80%94%E9%9D%9E%E9%80%92%E5%BD%92"><span class="toc-text">迭代法——非递归</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-41"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-34"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-34"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC-4-18"><span class="toc-text">12、513. 找树左下角的值(4.18)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-44"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">层序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-42"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-35"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-35"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-4-18"><span class="toc-text">13、112. 路径总和(4.18)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-45"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E6%80%9D%E8%B7%AF-1"><span class="toc-text">我的思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#carl%E6%80%9D%E8%B7%AF"><span class="toc-text">carl思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-43"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-36"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-36"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II-4-19"><span class="toc-text">14、113. 路径总和 II(4.19)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-46"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-44"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-37"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#python%E4%BB%A3%E7%A0%81-37"><span class="toc-text">python代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-4-20"><span class="toc-text">15、106. 从中序与后序遍历序列构造二叉树(4.20)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-47"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-45"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-38"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-4-20"><span class="toc-text">16、105. 从前序与中序遍历序列构造二叉树(4.20)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-46"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-4-21"><span class="toc-text">17、654. 最大二叉树(4.21)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-48"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%EF%BC%8C%E5%88%9B%E5%BB%BA%E5%B7%A6%E5%8F%B3%E6%95%B0%E7%BB%84%EF%BC%8C%E6%AF%94%E8%BE%83%E9%BA%BB%E7%83%A6"><span class="toc-text">一、分割数组，创建左右数组，比较麻烦</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84-%E4%B8%8D%E5%88%9B%E5%BB%BA%E5%B7%A6%E5%8F%B3%E6%95%B0%E7%BB%84%EF%BC%8C%E4%BC%A0%E7%B4%A2%E5%BC%95%E5%8E%BB%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3%EF%BC%8C%E6%95%88%E6%9E%9C%E4%B8%80%E6%A0%B7%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9B%B4%E5%8A%A0%E7%AE%80%E6%B4%81"><span class="toc-text">二、分割数组,不创建左右数组，传索引去进行迭代，效果一样，但是更加简洁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-47"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-39"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-4-21"><span class="toc-text">18、617. 合并二叉树(4.21)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-49"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E6%80%9D%E8%B7%AF-2"><span class="toc-text">我的思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-48"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-40"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-4-21"><span class="toc-text">19、700. 二叉搜索树中的搜索(4.21)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-50"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-text">迭代法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-49"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-41"><span class="toc-text">java代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-text">注意：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%8198-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-4-21"><span class="toc-text">20、98. 验证二叉搜索树(4.21)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-51"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95"><span class="toc-text">一、递归方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81carl%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%B0%8F%E5%80%BC%E7%9A%84%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95"><span class="toc-text">二、carl设置最小值的递归方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-50"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-42"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE-4-22"><span class="toc-text">21、530. 二叉搜索树的最小绝对差(4.22)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-52"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-51"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-43"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB-4-22-%E5%92%8C%E4%B8%8A%E4%B8%80%E4%B8%AA%E4%B8%80%E6%A0%B7"><span class="toc-text">22、783. 二叉搜索树节点最小距离(4.22) 和上一个一样</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-52"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0-4-22"><span class="toc-text">23、501. 二叉搜索树中的众数(4.22)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-53"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%9D%E8%B7%AF-%E4%BB%A3%E7%A0%81%E6%9C%89%E7%82%B9%E5%A4%8D%E6%9D%82%EF%BC%8C%E6%80%9D%E6%83%B3%E4%B8%8D%E9%9A%BE%EF%BC%8C%E5%86%99%E8%B5%B7%E6%9D%A5%E6%9C%89%E7%82%B9%E5%A4%8D%E6%9D%82"><span class="toc-text">1.普通二叉树思路(代码有点复杂，思想不难，写起来有点复杂)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-text">2.二叉搜索树的思路</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-53"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-44"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-4-23"><span class="toc-text">24、236. 二叉树的最近公共祖先(4.23)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-54"><span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E6%9D%A1%E4%BB%B6"><span class="toc-text">临界条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-text">处理逻辑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-54"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-45"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-4-24"><span class="toc-text">25、235. 二叉搜索树的最近公共祖先(4.24)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-55"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-46"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-4-24"><span class="toc-text">26、701. 二叉搜索树中的插入操作(4.24)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-55"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-56"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-47"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-4-25"><span class="toc-text">27、450. 删除二叉搜索树中的节点(4.25)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-56"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-57"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-48"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28%E3%80%81669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-4-26"><span class="toc-text">28、669. 修剪二叉搜索树(4.26)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-57"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-58"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-49"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E3%80%81108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-4-27"><span class="toc-text">29、108. 将有序数组转换为二叉搜索树(4.27)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-58"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-59"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-50"><span class="toc-text">java代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E3%80%81538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91-4-27"><span class="toc-text">30、538. 把二叉搜索树转换为累加树(4.27)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-59"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-60"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#java%E4%BB%A3%E7%A0%81-51"><span class="toc-text">java代码</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.add("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="none";
      cover_wrapper.style.display="none";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
              <a href="mailto:crazyzhang2024@163.com"
                class="social fas fa-envelope flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="https://github.com/CrazyZhang123"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://github.com/volantis-x/hexo-theme-volantis/#5.8.0" target="_blank" class="codename">Volantis</a>
        as theme
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © 2021-2024 张俊杰</a></p>

        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fortawesome/fontawesome-free/css/all.min.css");
  
  
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.js"></script>






<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->



<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/tags/sites.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/tags/friends.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/tags/contributors.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>









      <script>
  volantis.layoutHelper("comments",`<div id="giscus_container"></div>`)

  volantis.giscus = {};

  function check_giscus() {
    if (volantis.dark.mode === "dark") {
      volantis.giscus.Theme = 'dark';
    } else {
      volantis.giscus.Theme = 'light';
    }

    return document.getElementById("giscus_container");
  }

  function pjax_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;
    let cfg = Object.assign({"theme":{"light":"light","dark":"dark"}},pdata.commentConfig)
    const script = document.createElement('script');
    script.setAttribute('src', 'https://giscus.app/client.js');
    Object.keys(cfg).forEach(k=>{
      if (k != "theme") {
        script.setAttribute('data-'+k, cfg[k]);
      }
    })
    script.setAttribute('data-theme', volantis.giscus.Theme);
    script.setAttribute('crossorigin', "anonymous");
    HEAD.appendChild(script);
  }

  function dark_giscus() {
    const HEAD = check_giscus();
    if (!HEAD) return;

    const message = {
      setConfig: {
        theme: volantis.giscus.Theme
      }
    };
    const giscusIframe = document.querySelector('iframe.giscus-frame');
    giscusIframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
  }
  pjax_giscus();
  volantis.pjax.push(pjax_giscus);
  volantis.dark.push(dark_giscus);
</script>

    





<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>







  <script>



  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>












  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"圣者纯洁","url":"http://example.com/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"张俊杰","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://example.com/","sameAs":["https://github.com/volantis-x"],"description":"这是张俊杰的网站"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http://example.com/","name":"圣者纯洁"}},{"@type":"ListItem","position":2,"item":{"@id":"http://example.com/categories/leetcode/","name":"leetcode"}},{"@type":"ListItem","position":3,"item":{"@id":"http://example.com/2024/10/17/leetcode刷题/","name":"leetcode刷题(1)"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"圣者纯洁","url":"http://example.com/","keywords":null,"description":"这是张俊杰的网站","author":{"@type":"Person","name":"张俊杰","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://example.com/","description":"这是张俊杰的网站"},"publisher":{"@type":"Organization","name":"圣者纯洁","url":"http://example.com/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"http://example.com?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","headline":"leetcode刷题(1)","description":"这是张俊杰的网站","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2024/10/17/leetcode%E5%88%B7%E9%A2%98/"},"author":{"@type":"Person","name":"张俊杰","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://example.com/"},"publisher":{"@type":"Organization","name":"圣者纯洁","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"http://example.com/2024/10/17/leetcode%E5%88%B7%E9%A2%98/","wordCount":0,"datePublished":"2024-10-17T13:05:31.000Z","dateModified":"2024-10-17T13:21:08.283Z","articleSection":"leetcode","keywords":"刷题","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
    <!-- front-matter body_end begin -->
    <!-- front-matter body_end end -->
  </body>
</html>
